
diff --git a/README.md b/README.md
index bac67ee..1a5d85c 100644
--- a/README.md
+++ b/README.md
@@ -221,3 +221,13 @@ docker compose -f docker-compose.server.yml down
 - Legacy `/app/uploads/*.json` files are not used as runtime data sources.
 - If you need one-time import from old JSON registries, run manually:
   - `docker compose exec -T experiment-manager python -m app.scripts.migrate_json_to_pg --force`
+
+## PostgreSQL Runtime Notes (2026-02-21)
+
+- Runtime authority is PostgreSQL only. `state.py` dicts are no longer used as business source of truth.
+- FastAPI startup only does DB connectivity check + schema creation (`create_all`); it does not auto-seed sample business data.
+- JupyterHub resource quota policy is read from PostgreSQL key `app_kv_store.resource_policy` (not JSON file).
+- Offline JSON import remains available:
+  - `docker compose exec -T experiment-manager python -m app.scripts.migrate_json_to_pg --force`
+- PostgreSQL self-check script:
+  - `docker compose exec -T experiment-manager python -m app.scripts.postgres_self_check`
diff --git a/backend/app/api/v1/admin.py b/backend/app/api/v1/admin.py
index 9bed8ec..69f741c 100644
--- a/backend/app/api/v1/admin.py
+++ b/backend/app/api/v1/admin.py
@@ -1,4 +1,10 @@
-?from fastapi import APIRouter
+from typing import Optional
+
+from fastapi import APIRouter, Depends, File, UploadFile
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from ...db.session import get_db
+from ...services.admin_service import AdminService
 
 
 def _get_main_module():
@@ -7,344 +13,52 @@ def _get_main_module():
 
 
 main = _get_main_module()
+router = APIRouter()
 
 
-def _bind_main_symbols():
-    for name in dir(main):
-        if name.startswith("__"):
-            continue
-        globals().setdefault(name, getattr(main, name))
+def _service(db: AsyncSession) -> AdminService:
+    return AdminService(main_module=main, db=db)
 
 
-_bind_main_symbols()
-router = APIRouter()
+async def list_admin_teachers(admin_username: str, db: AsyncSession = Depends(get_db)):
+    return await _service(db).list_admin_teachers(admin_username=admin_username)
 
-async def list_admin_teachers(admin_username: str):
-    _ensure_admin(admin_username)
-    return _list_admin_teacher_items()
-
-async def create_admin_teacher(payload: TeacherCreateRequest):
-    admin_username = _normalize_text(payload.admin_username)
-    _ensure_admin(admin_username)
-
-    teacher_username = _normalize_text(payload.username)
-    real_name = _normalize_text(payload.real_name) or teacher_username
-    if not teacher_username:
-        raise HTTPException(status_code=400, detail="教师账号不能为空")
-    if is_admin(teacher_username):
-        raise HTTPException(status_code=409, detail="账号与管理员冲突")
-    if teacher_username in students_db:
-        raise HTTPException(status_code=409, detail="账号与学生学号冲突")
-    if is_teacher(teacher_username):
-        raise HTTPException(status_code=409, detail="教师账号已存在")
-
-    teachers_db[teacher_username] = TeacherRecord(
-        username=teacher_username,
-        real_name=real_name,
-        created_by=admin_username,
-        created_at=datetime.now(),
-    )
-    _save_user_registry()
-    _append_operation_log(
-        operator=admin_username,
-        action="teachers.create",
-        target=teacher_username,
-        detail=f"real_name={real_name}",
-    )
-    return {
-        "message": "教师账号已创建",
-        "teacher": {
-            "username": teacher_username,
-            "real_name": real_name,
-            "source": "registry",
-            "created_by": admin_username,
-            "created_at": teachers_db[teacher_username].created_at,
-        },
-    }
-
-async def delete_admin_teacher(teacher_username: str, admin_username: str):
-    _ensure_admin(admin_username)
-    normalized_teacher = _normalize_text(teacher_username)
-    if not normalized_teacher:
-        raise HTTPException(status_code=400, detail="教师账号不能为空")
-    if normalized_teacher in TEACHER_ACCOUNTS and normalized_teacher not in teachers_db:
-        raise HTTPException(status_code=400, detail="内置教师账号请通过环境变量修改")
-    if normalized_teacher not in teachers_db:
-        raise HTTPException(status_code=404, detail="教师账号不存在")
-
-    del teachers_db[normalized_teacher]
-    _save_user_registry()
-
-    overrides = resource_policy_db.get("overrides", {})
-    if isinstance(overrides, dict) and normalized_teacher in overrides:
-        overrides.pop(normalized_teacher, None)
-        resource_policy_db["overrides"] = overrides
-        _save_resource_policy()
-
-    teacher_account_password_hashes_db.pop(normalized_teacher, None)
-    account_security_questions_db.pop(normalized_teacher, None)
-    _save_user_registry()
-
-    _append_operation_log(
-        operator=admin_username,
-        action="teachers.delete",
-        target=normalized_teacher,
-    )
-    return {"message": "教师账号已删除", "username": normalized_teacher}
-
-async def list_admin_classes(teacher_username: str):
-    _ensure_teacher(teacher_username)
-    return sorted(_list_accessible_classes(teacher_username), key=lambda item: item.name)
-
-async def download_class_template(teacher_username: str, format: str = "xlsx"):
-    _ensure_teacher(teacher_username)
-    template_format = format.lower()
-
-    if template_format == "csv":
-        payload = _build_class_csv_template()
-        return StreamingResponse(
-            io.BytesIO(payload),
-            media_type="text/csv; charset=utf-8",
-            headers={"Content-Disposition": "attachment; filename=class_import_template.csv"},
-        )
-
-    if template_format == "xlsx":
-        payload = _build_class_xlsx_template()
-        return StreamingResponse(
-            io.BytesIO(payload),
-            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
-            headers={"Content-Disposition": "attachment; filename=class_import_template.xlsx"},
-        )
-
-    raise HTTPException(status_code=400, detail="format 必须是 xlsx 或 csv")
-
-async def import_admin_classes(teacher_username: str, file: UploadFile = File(...)):
-    _ensure_teacher(teacher_username)
-    normalized_teacher = _normalize_text(teacher_username)
-    if not file.filename:
-        raise HTTPException(status_code=400, detail="文件名不能为空")
-
-    file_content = await file.read()
-    parsed_rows = _parse_class_import_rows(file.filename, file_content)
-    now = datetime.now()
-
-    existing_class_names = {item.name for item in _list_accessible_classes(normalized_teacher)}
-    file_class_names = set()
-    success_classes: List[ClassRecord] = []
-    errors = []
-    skipped_count = 0
-
-    for row_number, row in parsed_rows:
-        admission_year_raw, major_name, class_name = row
-        normalized_year = _normalize_admission_year(admission_year_raw)
-        normalized_major = _normalize_text(major_name)
-        normalized_class = _normalize_text(class_name)
-
-        if not all([normalized_year, normalized_major, normalized_class]):
-            errors.append({"row": row_number, "reason": "required fields cannot be empty"})
-            continue
-
-        merged_class_name = _build_class_name(normalized_year, normalized_major, normalized_class)
-        if not merged_class_name:
-            errors.append({"row": row_number, "reason": "班级名称格式无效"})
-            continue
-
-        if merged_class_name in existing_class_names:
-            skipped_count += 1
-            errors.append({"row": row_number, "reason": f"班级重复（系统中已存在）: {merged_class_name}"})
-            continue
-
-        if merged_class_name in file_class_names:
-            skipped_count += 1
-            errors.append({"row": row_number, "reason": f"班级重复（文件内）: {merged_class_name}"})
-            continue
-
-        file_class_names.add(merged_class_name)
-        success_classes.append(
-            ClassRecord(
-                id=str(uuid.uuid4()),
-                name=merged_class_name,
-                created_by=normalized_teacher,
-                created_at=now,
-            )
-        )
-
-    for record in success_classes:
-        classes_db[record.id] = record
-
-    if success_classes:
-        _save_user_registry()
-    _append_operation_log(
-        operator=normalized_teacher,
-        action="classes.import",
-        target="classes",
-        detail=f"success={len(success_classes)}, skipped={skipped_count}, failed={len(errors) - skipped_count}",
-    )
 
-    failed_count = len(errors) - skipped_count
-    return {
-        "total_rows": len(parsed_rows),
-        "success_count": len(success_classes),
-        "skipped_count": skipped_count,
-        "failed_count": failed_count,
-        "errors": errors,
-    }
-
-async def create_admin_class(payload: ClassCreateRequest):
-    _ensure_teacher(payload.teacher_username)
-    normalized_teacher = _normalize_text(payload.teacher_username)
-    class_name = _normalize_text(payload.name)
-    if not class_name:
-        raise HTTPException(status_code=400, detail="班级名称不能为空")
-    if any(item.name == class_name for item in _list_accessible_classes(normalized_teacher)):
-        raise HTTPException(status_code=400, detail="班级已存在")
-
-    record = ClassRecord(
-        id=str(uuid.uuid4()),
-        name=class_name,
-        created_by=normalized_teacher,
-        created_at=datetime.now(),
-    )
-    classes_db[record.id] = record
-    _save_user_registry()
-    _append_operation_log(
-        operator=normalized_teacher,
-        action="classes.create",
-        target=class_name,
-        detail=f"class_id={record.id}",
-    )
-    return record
-
-async def delete_admin_class(class_id: str, teacher_username: str):
-    _ensure_teacher(teacher_username)
-    normalized_teacher = _normalize_text(teacher_username)
-    if class_id not in classes_db:
-        raise HTTPException(status_code=404, detail="班级不存在")
-
-    class_record = classes_db[class_id]
-    class_owner = _normalize_text(class_record.created_by)
-    if not _is_admin_user(normalized_teacher) and class_owner != normalized_teacher:
-        raise HTTPException(status_code=403, detail="不能删除其他教师创建的班级")
-
-    class_name = class_record.name
-    if any(
-        item.class_name == class_name and _student_owner_username(item) == class_owner
-        for item in students_db.values()
-    ):
-        raise HTTPException(status_code=409, detail="班级已被学生使用，无法删除")
-
-    del classes_db[class_id]
-    _save_user_registry()
-    _append_operation_log(
-        operator=normalized_teacher,
-        action="classes.delete",
-        target=class_name,
-        detail=f"class_id={class_id}",
-    )
-    return {"message": "班级已删除"}
-
-async def download_student_template(teacher_username: str, format: str = "xlsx"):
-    _ensure_teacher(teacher_username)
-    template_format = format.lower()
-
-    if template_format == "csv":
-        payload = _build_csv_template()
-        return StreamingResponse(
-            io.BytesIO(payload),
-            media_type="text/csv; charset=utf-8",
-            headers={"Content-Disposition": "attachment; filename=student_import_template.csv"},
-        )
-
-    if template_format == "xlsx":
-        payload = _build_xlsx_template()
-        return StreamingResponse(
-            io.BytesIO(payload),
-            media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
-            headers={"Content-Disposition": "attachment; filename=student_import_template.xlsx"},
-        )
-
-    raise HTTPException(status_code=400, detail="format 必须是 xlsx 或 csv")
-
-async def import_students(teacher_username: str, file: UploadFile = File(...)):
-    _ensure_teacher(teacher_username)
-    normalized_teacher = _normalize_text(teacher_username)
-    if not file.filename:
-        raise HTTPException(status_code=400, detail="文件名不能为空")
-
-    file_content = await file.read()
-    parsed_rows = _parse_student_import_rows(file.filename, file_content)
-
-    class_names = {item.name for item in _list_accessible_classes(normalized_teacher)}
-    existing_student_ids = set(students_db.keys())
-    file_student_ids = set()
-    now = datetime.now()
-
-    success_students: List[StudentRecord] = []
-    errors = []
-    skipped_count = 0
-
-    for row_number, row in parsed_rows:
-        student_id, real_name, class_name, organization, phone, admission_year_raw = row
-        admission_year = _normalize_admission_year(admission_year_raw) or _infer_admission_year(student_id)
-        if not all([student_id, real_name, class_name, organization, phone]):
-            errors.append({"row": row_number, "student_id": student_id, "reason": "字段不能为空"})
-            continue
-        if not admission_year:
-            errors.append({"row": row_number, "student_id": student_id, "reason": "入学年级无效"})
-            continue
-        if is_teacher(student_id):
-            errors.append({"row": row_number, "student_id": student_id, "reason": "student id conflicts with teacher account"})
-            continue
-        if class_name not in class_names:
-            errors.append({"row": row_number, "student_id": student_id, "reason": "class does not exist"})
-            continue
-        if student_id in existing_student_ids:
-            skipped_count += 1
-            errors.append({"row": row_number, "student_id": student_id, "reason": "学号重复（系统中已存在）"})
-            continue
-        if student_id in file_student_ids:
-            skipped_count += 1
-            errors.append({"row": row_number, "student_id": student_id, "reason": "duplicate student id in system"})
-            continue
-
-        file_student_ids.add(student_id)
-        success_students.append(
-            StudentRecord(
-                student_id=student_id,
-                username=student_id,
-                real_name=real_name,
-                class_name=class_name,
-                admission_year=admission_year,
-                organization=organization,
-                phone=phone,
-                role="student",
-                created_by=normalized_teacher,
-                password_hash=_hash_password(DEFAULT_PASSWORD),
-                created_at=now,
-                updated_at=now,
-            )
-        )
-
-    for item in success_students:
-        students_db[item.student_id] = item
-
-    if success_students:
-        _save_user_registry()
-    _append_operation_log(
-        operator=normalized_teacher,
-        action="students.import",
-        target="students",
-        detail=f"success={len(success_students)}, skipped={skipped_count}, failed={len(errors) - skipped_count}",
-    )
+async def create_admin_teacher(payload: main.TeacherCreateRequest, db: AsyncSession = Depends(get_db)):
+    return await _service(db).create_admin_teacher(payload=payload)
+
+
+async def delete_admin_teacher(teacher_username: str, admin_username: str, db: AsyncSession = Depends(get_db)):
+    return await _service(db).delete_admin_teacher(teacher_username=teacher_username, admin_username=admin_username)
+
+
+async def list_admin_classes(teacher_username: str, db: AsyncSession = Depends(get_db)):
+    return await _service(db).list_admin_classes(teacher_username=teacher_username)
+
+
+async def download_class_template(teacher_username: str, format: str = "xlsx", db: AsyncSession = Depends(get_db)):
+    return await _service(db).download_class_template(teacher_username=teacher_username, format=format)
+
+
+async def import_admin_classes(teacher_username: str, file: UploadFile = File(...), db: AsyncSession = Depends(get_db)):
+    return await _service(db).import_admin_classes(teacher_username=teacher_username, file=file)
+
+
+async def create_admin_class(payload: main.ClassCreateRequest, db: AsyncSession = Depends(get_db)):
+    return await _service(db).create_admin_class(payload=payload)
+
+
+async def delete_admin_class(class_id: str, teacher_username: str, db: AsyncSession = Depends(get_db)):
+    return await _service(db).delete_admin_class(class_id=class_id, teacher_username=teacher_username)
+
+
+async def download_student_template(teacher_username: str, format: str = "xlsx", db: AsyncSession = Depends(get_db)):
+    return await _service(db).download_student_template(teacher_username=teacher_username, format=format)
+
+
+async def import_students(teacher_username: str, file: UploadFile = File(...), db: AsyncSession = Depends(get_db)):
+    return await _service(db).import_students(teacher_username=teacher_username, file=file)
 
-    failed_count = len(errors) - skipped_count
-    return {
-        "total_rows": len(parsed_rows),
-        "success_count": len(success_students),
-        "skipped_count": skipped_count,
-        "failed_count": failed_count,
-        "errors": errors,
-    }
 
 async def list_admin_students(
     teacher_username: str,
@@ -353,430 +67,94 @@ async def list_admin_students(
     admission_year: str = "",
     page: int = 1,
     page_size: int = 20,
+    db: AsyncSession = Depends(get_db),
 ):
-    _ensure_teacher(teacher_username)
-    normalized_teacher = _normalize_text(teacher_username)
-    page = max(page, 1)
-    page_size = max(1, min(page_size, 100))
-
-    normalized_keyword = _normalize_text(keyword).lower()
-    normalized_class_name = _normalize_text(class_name)
-    normalized_admission_year = _normalize_admission_year(admission_year)
-    students = [item for item in students_db.values() if _student_visible_to_teacher(item, normalized_teacher)]
-
-    if normalized_keyword:
-        students = [
-            item for item in students
-            if normalized_keyword in item.student_id.lower() or normalized_keyword in item.real_name.lower()
-        ]
-
-    if normalized_class_name:
-        students = [item for item in students if item.class_name == normalized_class_name]
-    if normalized_admission_year:
-        students = [
-            item for item in students
-            if _normalize_admission_year(item.admission_year) == normalized_admission_year
-        ]
-
-    students.sort(key=lambda item: item.created_at, reverse=True)
-    total = len(students)
-    start = (page - 1) * page_size
-    end = start + page_size
-    paged_students = students[start:end]
-
-    return {
-        "total": total,
-        "page": page,
-        "page_size": page_size,
-        "items": [
-            {
-                "student_id": item.student_id,
-                "username": item.username,
-                "real_name": item.real_name,
-                "class_name": item.class_name,
-                "admission_year": _normalize_admission_year(item.admission_year),
-                "admission_year_label": _format_admission_year_label(item.admission_year),
-                "organization": item.organization,
-                "phone": item.phone,
-                "role": item.role,
-                "created_at": item.created_at,
-                "updated_at": item.updated_at,
-            }
-            for item in paged_students
-        ],
-    }
-
-async def list_admission_year_options(teacher_username: str):
-    _ensure_teacher(teacher_username)
-    normalized_teacher = _normalize_text(teacher_username)
-    year_set = {year for year in DEFAULT_ADMISSION_YEAR_OPTIONS}
-    year_set.update(
-        _normalize_admission_year(item.admission_year)
-        for item in students_db.values()
-        if _normalize_admission_year(item.admission_year) and _student_visible_to_teacher(item, normalized_teacher)
-    )
-    years = sorted(year_set)
-    return [{"value": year, "label": f"{year}级"} for year in years]
-
-async def reset_student_password(student_id: str, teacher_username: str):
-    _ensure_teacher(teacher_username)
-    normalized_teacher = _normalize_text(teacher_username)
-    if student_id not in students_db:
-        raise HTTPException(status_code=404, detail="学生不存在")
-
-    student = students_db[student_id]
-    if not _student_visible_to_teacher(student, normalized_teacher):
-        raise HTTPException(status_code=403, detail="不能操作其他教师的学生")
-    student.password_hash = _hash_password(DEFAULT_PASSWORD)
-    student.updated_at = datetime.now()
-    _save_user_registry()
-    _append_operation_log(
-        operator=normalized_teacher,
-        action="students.reset_password",
-        target=student_id,
-        detail="密码重置为默认密码",
-    )
-    return {"message": "密码已重置", "student_id": student_id}
-
-async def delete_student(student_id: str, teacher_username: str):
-    _ensure_teacher(teacher_username)
-    normalized_teacher = _normalize_text(teacher_username)
-    if student_id not in students_db:
-        raise HTTPException(status_code=404, detail="学生不存在")
-
-    if not _student_visible_to_teacher(students_db[student_id], normalized_teacher):
-        raise HTTPException(status_code=403, detail="不能删除其他教师的学生")
-    del students_db[student_id]
-    _save_user_registry()
-    _append_operation_log(
-        operator=normalized_teacher,
-        action="students.delete",
-        target=student_id,
-        detail="删除学生账号",
-    )
-    return {"message": "学生已删除", "student_id": student_id}
-
-async def batch_delete_students(teacher_username: str, class_name: str = ""):
-    _ensure_teacher(teacher_username)
-    normalized_teacher = _normalize_text(teacher_username)
-    normalized_class_name = _normalize_text(class_name)
-    if not normalized_class_name:
-        raise HTTPException(status_code=400, detail="class_name不能为空")
-
-    target_records = [
-        item
-        for item in students_db.values()
-        if item.class_name == normalized_class_name and _student_visible_to_teacher(item, normalized_teacher)
-    ]
-    target_ids = [item.student_id for item in target_records]
-
-    for student_id in target_ids:
-        del students_db[student_id]
-
-    if target_ids:
-        _save_user_registry()
-
-    _append_operation_log(
-        operator=normalized_teacher,
-        action="students.batch_delete",
-        target=normalized_class_name,
-        detail=f"class_name={normalized_class_name}, deleted={len(target_ids)}",
-    )
-    return {
-        "message": "批量删除完成",
-        "class_name": normalized_class_name,
-        "deleted_count": len(target_ids),
-        "deleted_student_ids": target_ids,
-    }
-
-async def get_resource_control_overview(admin_username: str):
-    _ensure_admin(admin_username)
-    budget = _normalize_resource_budget(resource_policy_db.get("budget", {}))
-    users = _collect_resource_control_users()
-    summary = _resource_assignment_summary(users, budget)
-    return {
-        "budget": budget,
-        "summary": summary,
-        "defaults": resource_policy_db.get("defaults", deepcopy(DEFAULT_RESOURCE_ROLE_LIMITS)),
-        "users": users,
-    }
-
-async def upsert_user_resource_quota(username: str, payload: ResourceQuotaUpdateRequest):
-    _ensure_admin(payload.admin_username)
-    target_user = _normalize_text(username)
-    if not target_user:
-        raise HTTPException(status_code=400, detail="username不能为空")
-
-    user_map = {item["username"]: item for item in _managed_users()}
-    user_item = user_map.get(target_user)
-    if not user_item:
-        raise HTTPException(status_code=404, detail="用户不存在，无法设置资源配额")
-
-    role = user_item["role"]
-    quota = _normalize_resource_quota(
-        {
-            "cpu_limit": payload.cpu_limit,
-            "memory_limit": payload.memory_limit,
-            "storage_limit": payload.storage_limit,
-        },
-        role,
-    )
-    now_iso = datetime.now().isoformat()
-    next_override = {
-        **quota,
-        "updated_by": _normalize_text(payload.admin_username),
-        "updated_at": now_iso,
-        "note": _normalize_text(payload.note)[:200],
-    }
-
-    current_overrides = resource_policy_db.get("overrides", {})
-    simulated_overrides = deepcopy(current_overrides)
-    simulated_overrides[target_user] = next_override
-
-    budget = _normalize_resource_budget(resource_policy_db.get("budget", {}))
-    simulated_rows = _collect_resource_control_users(overrides=simulated_overrides)
-    simulated_summary = _resource_assignment_summary(simulated_rows, budget)
-    _validate_budget(simulated_summary, budget)
-
-    resource_policy_db["overrides"] = simulated_overrides
-    resource_policy_db["budget"] = budget
-    _save_resource_policy()
-
-    _append_operation_log(
-        operator=payload.admin_username,
-        action="resource_quota.update",
-        target=target_user,
-        detail=f"cpu={quota['cpu_limit']}, memory={quota['memory_limit']}, storage={quota['storage_limit']}",
+    return await _service(db).list_admin_students(
+        teacher_username=teacher_username,
+        keyword=keyword,
+        class_name=class_name,
+        admission_year=admission_year,
+        page=page,
+        page_size=page_size,
     )
 
-    target_row = next((item for item in simulated_rows if item["username"] == target_user), None)
-    return {
-        "message": "资源配额已更新",
-        "item": target_row,
-        "summary": simulated_summary,
-    }
-
-async def delete_user_resource_quota_override(username: str, admin_username: str):
-    _ensure_admin(admin_username)
-    target_user = _normalize_text(username)
-    if not target_user:
-        raise HTTPException(status_code=400, detail="username不能为空")
-
-    if target_user not in {item["username"] for item in _managed_users()}:
-        raise HTTPException(status_code=404, detail="用户不存在")
-
-    current_overrides = resource_policy_db.get("overrides", {})
-    simulated_overrides = deepcopy(current_overrides)
-    simulated_overrides.pop(target_user, None)
-
-    budget = _normalize_resource_budget(resource_policy_db.get("budget", {}))
-    simulated_rows = _collect_resource_control_users(overrides=simulated_overrides)
-    simulated_summary = _resource_assignment_summary(simulated_rows, budget)
-    _validate_budget(simulated_summary, budget)
-
-    resource_policy_db["overrides"] = simulated_overrides
-    resource_policy_db["budget"] = budget
-    _save_resource_policy()
-
-    _append_operation_log(
-        operator=admin_username,
-        action="resource_quota.reset",
-        target=target_user,
-        detail="恢复默认资源配额",
-    )
 
-    return {
-        "message": "该用户已恢复默认资源配额",
-        "username": target_user,
-        "summary": simulated_summary,
-    }
-
-async def update_resource_budget(payload: ResourceBudgetUpdateRequest):
-    _ensure_admin(payload.admin_username)
-    budget = _normalize_resource_budget(
-        {
-            "max_total_cpu": payload.max_total_cpu,
-            "max_total_memory": payload.max_total_memory,
-            "max_total_storage": payload.max_total_storage,
-            "enforce_budget": payload.enforce_budget,
-            "updated_by": payload.admin_username,
-            "updated_at": datetime.now().isoformat(),
-        }
-    )
+async def list_admission_year_options(teacher_username: str, db: AsyncSession = Depends(get_db)):
+    return await _service(db).list_admission_year_options(teacher_username=teacher_username)
 
-    rows = _collect_resource_control_users()
-    summary = _resource_assignment_summary(rows, budget)
-    _validate_budget(summary, budget)
-
-    resource_policy_db["budget"] = budget
-    _save_resource_policy()
-
-    _append_operation_log(
-        operator=payload.admin_username,
-        action="resource_budget.update",
-        target="server-budget",
-        detail=(
-            f"cpu={budget['max_total_cpu']}, memory={budget['max_total_memory']}, "
-            f"storage={budget['max_total_storage']}, enforce={budget['enforce_budget']}"
-        ),
-    )
 
-    return {
-        "message": "服务器资源预算已更新",
-        "budget": budget,
-        "summary": summary,
-    }
-
-async def list_admin_operation_logs(admin_username: str, limit: int = 200):
-    _ensure_admin(admin_username)
-    safe_limit = max(1, min(limit, 1000))
-    items = sorted(operation_logs_db, key=lambda item: item.created_at, reverse=True)[:safe_limit]
-    return {
-        "total": len(operation_logs_db),
-        "limit": safe_limit,
-        "items": [_operation_log_to_dict(item) for item in items],
-    }
-
-async def cleanup_admin_operation_logs(admin_username: str, keep_recent: int = 200):
-    _ensure_admin(admin_username)
-    safe_keep = max(0, min(keep_recent, 1000))
-    before_count = len(operation_logs_db)
-    if safe_keep == 0:
-        operation_logs_db.clear()
-    elif before_count > safe_keep:
-        del operation_logs_db[: before_count - safe_keep]
-
-    removed_count = max(0, before_count - len(operation_logs_db))
-    _append_operation_log(
-        operator=admin_username,
-        action="operation_logs.cleanup",
-        target="operation-logs",
-        detail=f"removed={removed_count}, keep_recent={safe_keep}",
-    )
-    return {
-        "message": "操作日志清理完成",
-        "removed_count": removed_count,
-        "remaining": len(operation_logs_db),
-    }
+async def reset_student_password(student_id: str, teacher_username: str, db: AsyncSession = Depends(get_db)):
+    return await _service(db).reset_student_password(student_id=student_id, teacher_username=teacher_username)
+
+
+async def delete_student(student_id: str, teacher_username: str, db: AsyncSession = Depends(get_db)):
+    return await _service(db).delete_student(student_id=student_id, teacher_username=teacher_username)
+
+
+async def batch_delete_students(teacher_username: str, class_name: str = "", db: AsyncSession = Depends(get_db)):
+    return await _service(db).batch_delete_students(teacher_username=teacher_username, class_name=class_name)
+
+
+async def get_resource_control_overview(admin_username: str, db: AsyncSession = Depends(get_db)):
+    return await _service(db).get_resource_control_overview(admin_username=admin_username)
+
+
+async def upsert_user_resource_quota(
+    username: str,
+    payload: main.ResourceQuotaUpdateRequest,
+    db: AsyncSession = Depends(get_db),
+):
+    return await _service(db).upsert_user_resource_quota(username=username, payload=payload)
+
+
+async def delete_user_resource_quota_override(username: str, admin_username: str, db: AsyncSession = Depends(get_db)):
+    return await _service(db).delete_user_resource_quota_override(username=username, admin_username=admin_username)
+
+
+async def update_resource_budget(payload: main.ResourceBudgetUpdateRequest, db: AsyncSession = Depends(get_db)):
+    return await _service(db).update_resource_budget(payload=payload)
+
+
+async def list_admin_operation_logs(admin_username: str, limit: int = 200, db: AsyncSession = Depends(get_db)):
+    return await _service(db).list_admin_operation_logs(admin_username=admin_username, limit=limit)
+
+
+async def cleanup_admin_operation_logs(admin_username: str, keep_recent: int = 200, db: AsyncSession = Depends(get_db)):
+    return await _service(db).cleanup_admin_operation_logs(admin_username=admin_username, keep_recent=keep_recent)
+
 
 async def upload_resource_file(
     teacher_username: str,
-    file: UploadFile = File(...)
+    file: UploadFile = File(...),
+    db: AsyncSession = Depends(get_db),
 ):
-    """管理员上传资源文件"""
-    _ensure_teacher(teacher_username)
-
-    if not file.filename:
-        raise HTTPException(status_code=400, detail="文件名不能为空")
-
-    original_filename = os.path.basename(file.filename)
-    extension = os.path.splitext(original_filename)[1].lower()
-    if extension not in ALLOWED_RESOURCE_EXTENSIONS:
-        raise HTTPException(status_code=400, detail="暂不支持该文件类型")
-
-    safe_filename = original_filename.replace(" ", "_").replace("/", "_").replace("\\", "_")
-    resource_id = str(uuid.uuid4())
-    file_path = os.path.join(UPLOAD_DIR, f"resource_{resource_id}_{safe_filename}")
-
-    try:
-        with open(file_path, "wb") as buffer:
-            shutil.copyfileobj(file.file, buffer)
-    except Exception as exc:
-        raise HTTPException(status_code=500, detail=f"文件保存失败: {exc}") from exc
-
-    file_size = os.path.getsize(file_path)
-    if file_size <= 0:
-        if os.path.exists(file_path):
-            os.remove(file_path)
-        raise HTTPException(status_code=400, detail="上传文件为空")
-
-    inferred_content_type = file.content_type or mimetypes.guess_type(original_filename)[0] or "application/octet-stream"
-    record = ResourceFile(
-        id=resource_id,
-        filename=original_filename,
-        file_path=file_path,
-        file_type=extension.lstrip("."),
-        content_type=inferred_content_type,
-        size=file_size,
-        created_at=datetime.now(),
-        created_by=teacher_username,
-    )
-    resource_files_db[record.id] = record
-    _save_resource_registry()
-    return _resource_to_payload(record)
+    return await _service(db).upload_resource_file(teacher_username=teacher_username, file=file)
+
 
 async def list_resource_files(
     teacher_username: str,
     name: Optional[str] = None,
-    file_type: Optional[str] = None
+    file_type: Optional[str] = None,
+    db: AsyncSession = Depends(get_db),
 ):
-    """管理员查看资源文件列表"""
-    _ensure_teacher(teacher_username)
-    items = _list_resource_records(name_filter=name or "", type_filter=file_type or "")
-    payload_items = [_resource_to_payload(item) for item in items]
-    return {"total": len(payload_items), "items": payload_items}
-
-async def get_resource_file_detail(resource_id: str, teacher_username: str):
-    """管理员查看资源文件详情"""
-    _ensure_teacher(teacher_username)
-    record = _get_resource_or_404(resource_id)
-    _ensure_resource_file_exists(record)
-
-    payload = _resource_to_payload(record)
-    preview_mode = payload["preview_mode"]
-    if preview_mode in {"markdown", "text"}:
-        payload["preview_text"] = _read_text_preview(record.file_path)
-    elif preview_mode == "docx":
-        payload["preview_text"] = _read_docx_preview(record.file_path)
-    else:
-        payload["preview_text"] = ""
-    return payload
-
-async def delete_resource_file(resource_id: str, teacher_username: str):
-    """管理员删除资源文件"""
-    _ensure_teacher(teacher_username)
-    record = _get_resource_or_404(resource_id)
-
-    if os.path.exists(record.file_path):
-        try:
-            os.remove(record.file_path)
-        except OSError as exc:
-            raise HTTPException(status_code=500, detail=f"删除文件失败: {exc}") from exc
-
-    resource_files_db.pop(resource_id, None)
-    _save_resource_registry()
-    return {"message": "资源文件已删除", "id": resource_id}
-
-async def preview_resource_file(resource_id: str, teacher_username: str):
-    """在线预览资源文件"""
-    _ensure_teacher(teacher_username)
-    record = _get_resource_or_404(resource_id)
-    _ensure_resource_file_exists(record)
-
-    preview_mode = _resource_preview_mode(record)
-    if preview_mode != "pdf":
-        raise HTTPException(status_code=400, detail="该文件类型不支持二进制在线预览")
-
-    return FileResponse(
-        path=record.file_path,
-        filename="document.pdf",
-        media_type="application/pdf",
-        content_disposition_type="inline",
-    )
+    return await _service(db).list_resource_files(teacher_username=teacher_username, name=name, file_type=file_type)
+
+
+async def get_resource_file_detail(resource_id: str, teacher_username: str, db: AsyncSession = Depends(get_db)):
+    return await _service(db).get_resource_file_detail(resource_id=resource_id, teacher_username=teacher_username)
+
+
+async def delete_resource_file(resource_id: str, teacher_username: str, db: AsyncSession = Depends(get_db)):
+    return await _service(db).delete_resource_file(resource_id=resource_id, teacher_username=teacher_username)
+
+
+async def preview_resource_file(resource_id: str, teacher_username: str, db: AsyncSession = Depends(get_db)):
+    return await _service(db).preview_resource_file(resource_id=resource_id, teacher_username=teacher_username)
+
+
+async def download_resource_file(resource_id: str, teacher_username: str, db: AsyncSession = Depends(get_db)):
+    return await _service(db).download_resource_file(resource_id=resource_id, teacher_username=teacher_username)
 
-async def download_resource_file(resource_id: str, teacher_username: str):
-    """下载资源文件"""
-    _ensure_teacher(teacher_username)
-    record = _get_resource_or_404(resource_id)
-    _ensure_resource_file_exists(record)
-
-    media_type = record.content_type or mimetypes.guess_type(record.filename)[0] or "application/octet-stream"
-    return FileResponse(
-        path=record.file_path,
-        filename=record.filename,
-        media_type=media_type,
-        content_disposition_type="attachment",
-    )
 
 router.add_api_route("/api/admin/teachers", list_admin_teachers, methods=["GET"])
 router.add_api_route("/api/admin/teachers", create_admin_teacher, methods=["POST"])
@@ -805,3 +183,4 @@ router.add_api_route("/api/admin/resources/{resource_id}", get_resource_file_det
 router.add_api_route("/api/admin/resources/{resource_id}", delete_resource_file, methods=["DELETE"])
 router.add_api_route("/api/admin/resources/{resource_id}/preview", preview_resource_file, methods=["GET"])
 router.add_api_route("/api/admin/resources/{resource_id}/download", download_resource_file, methods=["GET"])
+
diff --git a/backend/app/api/v1/ai.py b/backend/app/api/v1/ai.py
index f44c47e..60cddae 100644
--- a/backend/app/api/v1/ai.py
+++ b/backend/app/api/v1/ai.py
@@ -1,4 +1,12 @@
-?from fastapi import APIRouter
+from datetime import datetime, timezone
+from typing import Dict, List, Optional
+
+from fastapi import APIRouter, Depends, HTTPException, Request
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from ...db.session import get_db
+from ...repositories import KVStoreRepository
+from ...services.identity_service import normalize_text, resolve_user_role
 
 
 def _get_main_module():
@@ -7,72 +15,125 @@ def _get_main_module():
 
 
 main = _get_main_module()
+router = APIRouter()
+
+
+async def _load_ai_shared_config(db: AsyncSession) -> dict:
+    row = await KVStoreRepository(db).get("ai_shared_config")
+    payload = row.value_json if row and isinstance(row.value_json, dict) else {}
+    normalized = dict(main.DEFAULT_AI_SHARED_CONFIG)
+    normalized.update(main._normalize_ai_shared_config(payload))
+    return normalized
 
 
-def _bind_main_symbols():
-    for name in dir(main):
-        if name.startswith("__"):
+async def _save_ai_shared_config(db: AsyncSession, payload: dict) -> None:
+    await KVStoreRepository(db).upsert("ai_shared_config", payload)
+    await db.commit()
+
+
+async def _load_ai_chat_history_map(db: AsyncSession) -> dict:
+    row = await KVStoreRepository(db).get("ai_chat_history")
+    payload = row.value_json if row and isinstance(row.value_json, dict) else {}
+    output = {}
+    for username, items in payload.items() if isinstance(payload, dict) else []:
+        normalized_username = normalize_text(username)
+        if not normalized_username:
             continue
-        globals().setdefault(name, getattr(main, name))
+        output[normalized_username] = main._normalize_chat_history_items(items)
+    return output
 
 
-_bind_main_symbols()
-router = APIRouter()
+async def _save_ai_chat_history_map(db: AsyncSession, payload: dict) -> None:
+    await KVStoreRepository(db).upsert("ai_chat_history", payload)
+    await db.commit()
 
-async def get_ai_shared_config(username: str, request: Request):
-    normalized_user = _normalize_text(username)
-    if not normalized_user:
-        raise HTTPException(status_code=400, detail="username不能为空")
-    if not _is_known_user(normalized_user):
-        raise HTTPException(status_code=404, detail="用户不存在")
-    _require_ai_session(request, expected_username=normalized_user, allow_admin_override=True)
-    return _build_ai_shared_config_response(include_secrets=False)
 
-async def update_ai_shared_config(payload: AISharedConfigUpdateRequest, request: Request):
-    teacher_username = _normalize_text(payload.teacher_username)
-    _require_ai_session(request, expected_username=teacher_username, allow_admin_override=True)
-    _ensure_teacher(teacher_username)
+async def _is_known_user(db: AsyncSession, username: str) -> bool:
+    return bool(await resolve_user_role(db, username))
 
-    updated = _normalize_ai_shared_config(payload.dict())
-    ai_shared_config_db.update(updated)
-    _save_ai_shared_config()
-    return _build_ai_shared_config_response(include_secrets=False)
 
-async def get_ai_chat_history(username: str, request: Request):
-    normalized_user = _normalize_text(username)
+async def get_ai_shared_config(username: str, request: Request, db: AsyncSession = Depends(get_db)):
+    normalized_user = normalize_text(username)
     if not normalized_user:
         raise HTTPException(status_code=400, detail="username不能为空")
-    if not _is_known_user(normalized_user):
+    if not await _is_known_user(db, normalized_user):
         raise HTTPException(status_code=404, detail="用户不存在")
-    _require_ai_session(request, expected_username=normalized_user, allow_admin_override=True)
+    main._require_ai_session(request, expected_username=normalized_user, allow_admin_override=True)
+    config = await _load_ai_shared_config(db)
+    sanitized = dict(config)
+    sanitized["api_key"] = ""
+    sanitized["tavily_api_key"] = ""
+    return main.AISharedConfigResponse(**sanitized)
+
+
+async def update_ai_shared_config(
+    payload: main.AISharedConfigUpdateRequest,
+    request: Request,
+    db: AsyncSession = Depends(get_db),
+):
+    teacher_username = normalize_text(payload.teacher_username)
+    main._require_ai_session(request, expected_username=teacher_username, allow_admin_override=True)
+    role = await resolve_user_role(db, teacher_username)
+    if role not in {"teacher", "admin"}:
+        raise HTTPException(status_code=403, detail="权限不足")
+
+    updated = main._normalize_ai_shared_config(payload.dict())
+    await _save_ai_shared_config(db, updated)
+    sanitized = dict(updated)
+    sanitized["api_key"] = ""
+    sanitized["tavily_api_key"] = ""
+    return main.AISharedConfigResponse(**sanitized)
+
+
+async def get_ai_chat_history(username: str, request: Request, db: AsyncSession = Depends(get_db)):
+    normalized_user = normalize_text(username)
+    if not normalized_user:
+        raise HTTPException(status_code=400, detail="username不能为空")
+    if not await _is_known_user(db, normalized_user):
+        raise HTTPException(status_code=404, detail="用户不存在")
+    main._require_ai_session(request, expected_username=normalized_user, allow_admin_override=True)
 
-    messages = _get_ai_chat_history(normalized_user)
-    return AIChatHistoryResponse(
+    history_map = await _load_ai_chat_history_map(db)
+    messages = history_map.get(normalized_user, [])
+    return main.AIChatHistoryResponse(
         username=normalized_user,
         message_count=len(messages),
-        messages=[AIChatHistoryMessage(**item) for item in messages],
+        messages=[main.AIChatHistoryMessage(**item) for item in messages],
     )
 
-async def update_ai_chat_history(payload: AIChatHistoryUpdateRequest, request: Request):
-    normalized_user = _normalize_text(payload.username)
+
+async def update_ai_chat_history(
+    payload: main.AIChatHistoryUpdateRequest,
+    request: Request,
+    db: AsyncSession = Depends(get_db),
+):
+    normalized_user = normalize_text(payload.username)
     if not normalized_user:
         raise HTTPException(status_code=400, detail="username不能为空")
-    if not _is_known_user(normalized_user):
+    if not await _is_known_user(db, normalized_user):
         raise HTTPException(status_code=404, detail="用户不存在")
-    _require_ai_session(request, expected_username=normalized_user, allow_admin_override=True)
+    main._require_ai_session(request, expected_username=normalized_user, allow_admin_override=True)
 
+    history_map = await _load_ai_chat_history_map(db)
     raw_messages = [{"role": item.role, "content": item.content} for item in payload.messages]
-    saved = _set_ai_chat_history(normalized_user, raw_messages)
-    return AIChatHistoryResponse(
+    normalized_messages = main._normalize_chat_history_items(raw_messages)
+    if normalized_messages:
+        history_map[normalized_user] = normalized_messages
+    else:
+        history_map.pop(normalized_user, None)
+
+    await _save_ai_chat_history_map(db, history_map)
+    return main.AIChatHistoryResponse(
         username=normalized_user,
-        message_count=len(saved),
-        messages=[AIChatHistoryMessage(**item) for item in saved],
+        message_count=len(normalized_messages),
+        messages=[main.AIChatHistoryMessage(**item) for item in normalized_messages],
     )
 
+
 async def ai_network_time(request: Request):
-    _require_ai_session(request)
+    main._require_ai_session(request)
     system_now = datetime.now().astimezone()
-    network_time, errors = _fetch_network_time()
+    network_time, errors = main._fetch_network_time()
     return {
         "network_available": bool(network_time),
         "network_time": network_time,
@@ -84,28 +145,39 @@ async def ai_network_time(request: Request):
         "errors": errors[:3],
     }
 
-async def ai_web_search(payload: AIWebSearchRequest, request: Request):
-    _require_ai_session(request)
-    return _run_web_search(payload.query, payload.limit)
 
-async def ai_chat_with_search(payload: AIChatWithSearchRequest, request: Request):
-    username = _normalize_text(payload.username)
+async def ai_web_search(payload: main.AIWebSearchRequest, request: Request, db: AsyncSession = Depends(get_db)):
+    main._require_ai_session(request)
+    config = await _load_ai_shared_config(db)
+    main._refresh_ai_shared_config_cache(config)
+    return main._run_web_search(payload.query, payload.limit)
+
+
+async def ai_chat_with_search(
+    payload: main.AIChatWithSearchRequest,
+    request: Request,
+    db: AsyncSession = Depends(get_db),
+):
+    username = normalize_text(payload.username)
     if not username:
         raise HTTPException(status_code=400, detail="username不能为空")
-    if not _is_known_user(username):
+    if not await _is_known_user(db, username):
         raise HTTPException(status_code=404, detail="用户不存在")
-    _require_ai_session(request, expected_username=username, allow_admin_override=True)
+    main._require_ai_session(request, expected_username=username, allow_admin_override=True)
 
-    message = _normalize_text(payload.message)
+    message = normalize_text(payload.message)
     if not message:
         raise HTTPException(status_code=400, detail="message不能为空")
-    is_today_relative = _is_today_relative_query(message)
-    is_time_sensitive = _is_time_sensitive_query(message)
+    is_today_relative = main._is_today_relative_query(message)
+    is_time_sensitive = main._is_time_sensitive_query(message)
+
+    config = await _load_ai_shared_config(db)
+    main._refresh_ai_shared_config_cache(config)
 
-    model = _normalize_text(payload.model) or _normalize_text(ai_shared_config_db.get("chat_model")) or DEFAULT_AI_SHARED_CONFIG["chat_model"]
-    base_url = _normalize_text(ai_shared_config_db.get("base_url")) or DEFAULT_AI_SHARED_CONFIG["base_url"]
-    api_key = _normalize_text(ai_shared_config_db.get("api_key"))
-    system_prompt = _normalize_text(ai_shared_config_db.get("system_prompt")) or DEFAULT_AI_SHARED_CONFIG["system_prompt"]
+    model = normalize_text(payload.model) or normalize_text(config.get("chat_model")) or main.DEFAULT_AI_SHARED_CONFIG["chat_model"]
+    base_url = normalize_text(config.get("base_url")) or main.DEFAULT_AI_SHARED_CONFIG["base_url"]
+    api_key = normalize_text(config.get("api_key"))
+    system_prompt = normalize_text(config.get("system_prompt")) or main.DEFAULT_AI_SHARED_CONFIG["system_prompt"]
     if not api_key:
         raise HTTPException(status_code=400, detail="AI 配置未保存 API Key，请先在教师端 AI 模块保存配置")
 
@@ -113,14 +185,14 @@ async def ai_chat_with_search(payload: AIChatWithSearchRequest, request: Request
     search_decision_reason = "联网模式已关闭"
     if payload.use_web_search and payload.auto_web_search:
         try:
-            need_web_search, search_decision_reason = _decide_need_web_search(
+            need_web_search, search_decision_reason = main._decide_need_web_search(
                 message=message,
                 model=model,
                 base_url=base_url,
                 api_key=api_key,
             )
         except HTTPException:
-            need_web_search, search_decision_reason = _fallback_need_web_search_decision(message)
+            need_web_search, search_decision_reason = main._fallback_need_web_search_decision(message)
             search_decision_reason = f"AI decision failed, fallback rule used: {search_decision_reason}"
     elif payload.use_web_search:
         search_decision_reason = "联网模式强制开启（跳过 AI 判定）"
@@ -133,7 +205,7 @@ async def ai_chat_with_search(payload: AIChatWithSearchRequest, request: Request
     search_error = ""
     if need_web_search:
         try:
-            search_payload = _run_web_search(message, payload.search_limit)
+            search_payload = main._run_web_search(message, payload.search_limit)
             search_provider = str(search_payload.get("provider") or "")
             search_resolved_query = str(search_payload.get("resolved_query") or message)
             search_cached = bool(search_payload.get("cached"))
@@ -142,14 +214,13 @@ async def ai_chat_with_search(payload: AIChatWithSearchRequest, request: Request
             if isinstance(raw_results, list):
                 search_results = [item for item in raw_results if isinstance(item, dict)]
         except HTTPException as exc:
-            # Degrade gracefully to plain model answer when network search is unavailable.
             search_error = str(exc.detail)
 
-    search_context = _build_web_search_context(search_results)
+    search_context = main._build_web_search_context(search_results)
 
-    system_parts = [system_prompt, AI_RESPONSE_STYLE_RULES]
+    system_parts = [system_prompt, main.AI_RESPONSE_STYLE_RULES]
     if is_time_sensitive:
-        date_tokens = _current_local_date_tokens()
+        date_tokens = main._current_local_date_tokens()
         system_parts.append(
             f"Current server date is {date_tokens['cn']} ({date_tokens['iso']}). "
             "Do not present historical events as if they happened today. "
@@ -165,35 +236,21 @@ async def ai_chat_with_search(payload: AIChatWithSearchRequest, request: Request
     final_system_prompt = "\n".join(part for part in system_parts if part)
 
     messages: List[Dict[str, str]] = [{"role": "system", "content": final_system_prompt}]
-
     raw_history = payload.history if isinstance(payload.history, list) else []
-    # “今天/最新”类问题很容易被历史对话中的旧日期污染，默认不带历史。
-    trimmed_history = [] if is_today_relative else _trim_ai_history_for_context(raw_history)
+    trimmed_history = [] if is_today_relative else main._trim_ai_history_for_context(raw_history)
     for item in trimmed_history:
-        messages.append({
-            "role": item.get("role", "user"),
-            "content": str(item.get("content") or ""),
-        })
+        messages.append({"role": item.get("role", "user"), "content": str(item.get("content") or "")})
 
     user_content = message
     if search_context:
         user_content = f"{message}\n\n{search_context}"
     messages.append({"role": "user", "content": user_content})
 
-    answer = _call_ai_chat_model(
-        model=model,
-        messages=messages,
-        base_url=base_url,
-        api_key=api_key,
-    )
-
+    answer = main._call_ai_chat_model(model=model, messages=messages, base_url=base_url, api_key=api_key)
     return {
         "answer": answer,
         "model": model,
-        "search_decision": {
-            "need_web_search": bool(need_web_search),
-            "reason": search_decision_reason,
-        },
+        "search_decision": {"need_web_search": bool(need_web_search), "reason": search_decision_reason},
         "search_provider": search_provider,
         "search_resolved_query": search_resolved_query or message,
         "search_cached": search_cached,
@@ -202,51 +259,29 @@ async def ai_chat_with_search(payload: AIChatWithSearchRequest, request: Request
         "search_error": search_error,
     }
 
+
 async def ai_code_review(code: str, language: str = "python"):
-    """AI代码审查"""
-    # 这里集成 AI 模型进行代码审查
-    # 示例返回
     return {
         "issues": [
             {"line": 5, "type": "warning", "message": "变量名不规范"},
-            {"line": 12, "type": "error", "message": "缺少异常处理"}
+            {"line": 12, "type": "error", "message": "缺少异常处理"},
         ],
-        "suggestions": [
-            "建议添加类型注解",
-            "考虑使用列表推导式优化性能"
-        ],
-        "overall_score": 85
+        "suggestions": ["建议添加类型注解", "考虑使用列表推导式优化性能"],
+        "overall_score": 85,
     }
 
+
 async def ai_explain_code(code: str):
-    """AI代码解释"""
-    return {
-        "explanation": "这段代码实现了...",
-        "key_concepts": ["循环", "条件判断", "列表操作"],
-        "complexity": "O(n)"
-    }
+    return {"explanation": "这段代码实现了...", "key_concepts": ["循环", "条件判断", "列表操作"], "complexity": "O(n)"}
+
 
 async def ai_debug_help(code: str, error_message: str):
-    """AI调试帮助"""
-    return {
-        "possible_causes": [
-            "数组越界",
-            "类型不匹配"
-        ],
-        "suggestions": [
-            "检查循环索引范围",
-            "使用try-except捕获异常"
-        ],
-        "fixed_code": "# 修复后的代码..."
-    }
+    return {"possible_causes": ["数组越界", "类型不匹配"], "suggestions": ["检查循环索引范围", "使用try-except捕获异常"], "fixed_code": "# 修复后的代码..."}
+
 
 async def ai_chat(question: str, context: Optional[str] = None):
-    """AI问答助手"""
-    return {
-        "answer": "根据你的问题...",
-        "related_topics": ["Python基础", "数据结构"],
-        "references": ["官方文档链接"]
-    }
+    return {"answer": "根据你的问题...", "related_topics": ["Python基础", "数据结构"], "references": ["官方文档链接"]}
+
 
 router.add_api_route("/api/ai/config", get_ai_shared_config, methods=["GET"], response_model=main.AISharedConfigResponse)
 router.add_api_route("/api/ai/config", update_ai_shared_config, methods=["PUT"], response_model=main.AISharedConfigResponse)
diff --git a/backend/app/api/v1/attachments.py b/backend/app/api/v1/attachments.py
index 718a2d1..fe9babe 100644
--- a/backend/app/api/v1/attachments.py
+++ b/backend/app/api/v1/attachments.py
@@ -79,16 +79,10 @@ async def download_attachment_word(
     db: Optional[AsyncSession] = Depends(get_db),
 ):
     service = build_attachment_service(main_module=main, db=db)
-    att = await service.get_attachment(attachment_id=attachment_id)
-    if not os.path.exists(att.file_path):
+    target_attachment = await service.find_paired_word_attachment(attachment_id=attachment_id)
+    if not os.path.exists(target_attachment.file_path):
         raise HTTPException(status_code=404, detail="attachment file not found")
 
-    target_attachment = att
-    if main._is_pdf_attachment(att):
-        paired_word = main._find_paired_word_attachment(att)
-        if paired_word is not None:
-            target_attachment = paired_word
-
     lower_filename = target_attachment.filename.lower()
     if lower_filename.endswith(".docx"):
         media_type = "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
diff --git a/backend/app/api/v1/auth.py b/backend/app/api/v1/auth.py
index 38b92c0..e67883f 100644
--- a/backend/app/api/v1/auth.py
+++ b/backend/app/api/v1/auth.py
@@ -1,5 +1,4 @@
-?from datetime import datetime
-from typing import Optional
+?from typing import Optional
 
 from fastapi import APIRouter, Depends, HTTPException
 from pydantic import BaseModel
@@ -9,6 +8,8 @@ from ...db.session import get_db
 from ...repositories.security import SecurityQuestionRepository
 from ...repositories.users import UserRepository
 from ...services.auth_service import AuthService
+from ...services.identity_service import normalize_text, resolve_user_role
+from ...services.operation_log_service import append_operation_log
 
 router = APIRouter()
 
@@ -42,7 +43,7 @@ async def _postgres_login_or_none(main, db: AsyncSession, username: str, passwor
     if auth_user is None:
         return None
 
-    account_username = main._normalize_text(auth_user.username or auth_user.email)
+    account_username = normalize_text(auth_user.username or auth_user.email)
     role = _role_value(auth_user.role).lower()
     if role in {"admin", "teacher"}:
         return {
@@ -60,8 +61,8 @@ async def _postgres_login_or_none(main, db: AsyncSession, username: str, passwor
         return None
 
     security_question_set = bool(main._normalize_security_question(student.security_question or ""))
-    student_username = main._normalize_text(student.username or student.student_id or account_username)
-    student_id = main._normalize_text(student.student_id or student_username)
+    student_username = normalize_text(student.username or student.student_id or account_username)
+    student_id = normalize_text(student.student_id or student_username)
     return {
         "username": student_username,
         "role": "student",
@@ -77,17 +78,19 @@ async def _postgres_login_or_none(main, db: AsyncSession, username: str, passwor
     }
 
 
-def _append_reset_password_log(main, username: str, role: str):
-    normalized_role = main._normalize_text(role).lower()
+async def _append_reset_password_log(db: AsyncSession, username: str, role: str):
+    normalized_role = normalize_text(role).lower()
     if normalized_role in {"teacher", "admin"}:
-        main._append_operation_log(
+        await append_operation_log(
+            db,
             operator=username,
             action="accounts.reset_password_with_security",
             target=username,
             detail="教师/管理员通过密保重置密码",
         )
         return
-    main._append_operation_log(
+    await append_operation_log(
+        db,
         operator=username,
         action="students.reset_password_with_security",
         target=username,
@@ -102,7 +105,7 @@ async def login(
 ):
     """统一登录入口"""
     main = _get_main_module()
-    username = main._normalize_text(payload.username)
+    username = normalize_text(payload.username)
     password = payload.password or ""
     if not username or not password:
         raise HTTPException(status_code=400, detail="用户名和密码不能为空")
@@ -116,7 +119,7 @@ async def login(
 @router.get("/api/auth/security-question")
 async def get_security_question(username: str, db: AsyncSession = Depends(get_db)):
     main = _get_main_module()
-    normalized_username = main._normalize_text(username)
+    normalized_username = normalize_text(username)
     if not normalized_username:
         raise HTTPException(status_code=400, detail="用户名不能为空")
 
@@ -124,7 +127,7 @@ async def get_security_question(username: str, db: AsyncSession = Depends(get_db
     auth_user = await auth_service.get_user_by_identifier(normalized_username)
 
     if auth_user is not None:
-        account_username = main._normalize_text(auth_user.username or auth_user.email or normalized_username)
+        account_username = normalize_text(auth_user.username or auth_user.email or normalized_username)
         role = _role_value(auth_user.role).lower()
         if role in {"teacher", "admin"}:
             sec_repo = SecurityQuestionRepository(db)
@@ -142,7 +145,7 @@ async def get_security_question(username: str, db: AsyncSession = Depends(get_db
     student = await user_repo.get_student_by_student_id(normalized_username)
     if student is None:
         student = await user_repo.get_by_username(normalized_username)
-    if student is None or main._normalize_text(student.role).lower() != "student":
+    if student is None or normalize_text(student.role).lower() != "student":
         raise HTTPException(status_code=404, detail="账号不存在")
 
     question = main._normalize_security_question(student.security_question or "")
@@ -157,7 +160,7 @@ async def reset_password_with_security_question(
     db: AsyncSession = Depends(get_db),
 ):
     main = _get_main_module()
-    normalized_username = main._normalize_text(payload.username)
+    normalized_username = normalize_text(payload.username)
     security_answer = payload.security_answer or ""
     new_password = payload.new_password or ""
 
@@ -175,85 +178,58 @@ async def reset_password_with_security_question(
     if auth_user is None:
         student_row = await user_repo.get_student_by_student_id(normalized_username)
         if student_row is not None:
-            resolved_username = main._normalize_text(student_row.username or student_row.student_id)
+            resolved_username = normalize_text(student_row.username or student_row.student_id)
             auth_user = await service.get_user_by_identifier(resolved_username)
 
     if auth_user is None:
         raise HTTPException(status_code=404, detail="账号不存在")
 
-    account_username = main._normalize_text(auth_user.username or auth_user.email or normalized_username)
+    account_username = normalize_text(auth_user.username or auth_user.email or normalized_username)
     role = _role_value(auth_user.role).lower()
 
     if role in {"teacher", "admin"}:
         sec_row = await sec_repo.get_by_username(account_username)
         question = main._normalize_security_question(sec_row.question if sec_row else "")
-        answer_hash = main._normalize_text(sec_row.answer_hash if sec_row else "")
+        answer_hash = normalize_text(sec_row.answer_hash if sec_row else "")
         if not question or not answer_hash:
             raise HTTPException(status_code=400, detail="该账号未设置密保问题")
         if not main._verify_security_answer(answer_hash, security_answer):
             raise HTTPException(status_code=401, detail="密保答案错误")
-        student_id = None
     else:
         if student_row is None:
             student_row = await user_repo.get_by_username(account_username)
         if student_row is None:
             student_row = await user_repo.get_student_by_student_id(account_username)
-        if student_row is None or main._normalize_text(student_row.role).lower() != "student":
+        if student_row is None or normalize_text(student_row.role).lower() != "student":
             raise HTTPException(status_code=404, detail="账号不存在")
 
         question = main._normalize_security_question(student_row.security_question or "")
-        answer_hash = main._normalize_text(student_row.security_answer_hash or "")
+        answer_hash = normalize_text(student_row.security_answer_hash or "")
         if not question or not answer_hash:
             raise HTTPException(status_code=400, detail="该账号未设置密保问题")
         if not main._verify_security_answer(answer_hash, security_answer):
             raise HTTPException(status_code=401, detail="密保答案错误")
-        student_id = main._normalize_text(student_row.student_id or student_row.username)
 
     new_hash = main._hash_password(new_password)
     changed = await service.set_password(auth_user.id, new_hash)
     if changed is None:
         raise HTTPException(status_code=500, detail="密码重置失败")
 
+    await _append_reset_password_log(db, account_username, role if role in {"teacher", "admin"} else "student")
     try:
         await db.commit()
     except Exception:
         await db.rollback()
         raise HTTPException(status_code=500, detail="密码重置失败")
 
-    normalized_role = role if role in {"teacher", "admin"} else "student"
-    if normalized_role in {"teacher", "admin"}:
-        if new_hash == main._default_password_hash():
-            main.teacher_account_password_hashes_db.pop(account_username, None)
-        else:
-            main.teacher_account_password_hashes_db[account_username] = new_hash
-    elif student_id and student_id in main.students_db:
-        main.students_db[student_id].password_hash = new_hash
-        main.students_db[student_id].updated_at = datetime.now()
-
-    _append_reset_password_log(main, account_username, normalized_role)
     return {"message": "密码重置成功"}
 
 
 async def check_role(username: str, db: AsyncSession = Depends(get_db)):
     """检查用户角色"""
-    main = _get_main_module()
-    normalized = main._normalize_text(username)
-
-    service = AuthService(db=db, password_hasher=main._hash_password)
-    auth_user = await service.get_user_by_identifier(normalized)
-    if auth_user is not None:
-        role = _role_value(auth_user.role).lower() or "student"
-    elif main.is_admin(normalized):
-        role = "admin"
-    elif main.is_teacher(normalized):
-        role = "teacher"
-    else:
-        role = "student"
-
-    return {
-        "username": normalized,
-        "role": role,
-    }
+    normalized = normalize_text(username)
+    role = await resolve_user_role(db, normalized) or "student"
+    return {"username": normalized, "role": role}
 
 
 router.add_api_route("/api/check-role", check_role, methods=["GET"])
diff --git a/backend/app/api/v1/jupyterhub.py b/backend/app/api/v1/jupyterhub.py
index 18ec576..a68d7ff 100644
--- a/backend/app/api/v1/jupyterhub.py
+++ b/backend/app/api/v1/jupyterhub.py
@@ -6,6 +6,7 @@ from sqlalchemy.ext.asyncio import AsyncSession
 from ...db.session import get_db
 from ...repositories.experiments import ExperimentRepository
 from ...repositories.users import UserRepository
+from ...services.identity_service import normalize_text, resolve_user_role
 
 
 def _get_main_module():
@@ -76,25 +77,26 @@ async def get_jupyterhub_auto_login_url(
 ):
     """Return a tokenized JupyterLab URL so portal users don't need a second Hub login."""
     main = _get_main_module()
-    user = main._normalize_text(username)
+    user = normalize_text(username)
     if not user:
         raise HTTPException(status_code=400, detail="username不能为空")
 
     target_experiment = None
     notebook_relpath = None
-    normalized_experiment_id = main._normalize_text(experiment_id)
+    normalized_experiment_id = normalize_text(experiment_id)
     if normalized_experiment_id:
         exp_row = await ExperimentRepository(db).get(normalized_experiment_id)
         if not exp_row:
             raise HTTPException(status_code=404, detail="实验不存在")
         target_experiment = _to_experiment_model(main, exp_row)
 
-        if not (main.is_teacher(user) or main.is_admin(user)):
+        role = await resolve_user_role(db, user)
+        if role not in {"teacher", "admin"}:
             user_repo = UserRepository(db)
             student_row = await user_repo.get_student_by_student_id(user)
             if student_row is None:
                 student_row = await user_repo.get_by_username(user)
-            if student_row is None or main._normalize_text(student_row.role).lower() != "student":
+            if student_row is None or normalize_text(student_row.role).lower() != "student":
                 raise HTTPException(status_code=404, detail="学生不存在")
 
             student = _to_student_record(main, student_row)
diff --git a/backend/app/api/v1/student.py b/backend/app/api/v1/student.py
index ca6e254..c2be95c 100644
--- a/backend/app/api/v1/student.py
+++ b/backend/app/api/v1/student.py
@@ -1,4 +1,4 @@
-import mimetypes
+?import mimetypes
 from typing import Optional
 
 from fastapi import APIRouter, Depends, HTTPException
@@ -6,6 +6,8 @@ from fastapi.responses import FileResponse
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from ...db.session import get_db
+from ...repositories import ResourceRepository
+from ...services.identity_service import ensure_student_user, normalize_text
 from ...services.student_service import build_student_service
 
 
@@ -50,59 +52,137 @@ async def change_student_password(
     return await service.change_student_password(payload=payload)
 
 
+def _resource_preview_mode(file_type: str) -> str:
+    normalized = normalize_text(file_type).lower().lstrip(".")
+    if normalized == "pdf":
+        return "pdf"
+    if normalized in {"xls", "xlsx"}:
+        return "sheet"
+    if normalized in {"md", "markdown"}:
+        return "markdown"
+    if normalized in {"txt", "csv", "json", "py", "log"}:
+        return "text"
+    if normalized == "docx":
+        return "docx"
+    return "unsupported"
+
+
 async def list_student_resource_files(
     student_id: str,
     name: Optional[str] = None,
     file_type: Optional[str] = None,
+    db: Optional[AsyncSession] = Depends(get_db),
 ):
-    main._ensure_student(student_id)
-    items = main._list_resource_records(name_filter=name or "", type_filter=file_type or "")
-    payload_items = [main._resource_to_payload(item, route_prefix="/api/student/resources") for item in items]
+    if db is None:
+        raise HTTPException(status_code=503, detail="PostgreSQL session unavailable")
+    await ensure_student_user(db, student_id)
+
+    normalized_name = normalize_text(name).lower()
+    normalized_type = normalize_text(file_type).lower().lstrip(".")
+    rows = await ResourceRepository(db).list_all()
+
+    payload_items = []
+    for row in rows:
+        if normalized_name and normalized_name not in normalize_text(row.filename).lower():
+            continue
+        if normalized_type and normalize_text(row.file_type).lower().lstrip(".") != normalized_type:
+            continue
+        if not main.os.path.exists(row.file_path):
+            continue
+        preview_mode = _resource_preview_mode(row.file_type)
+        payload_items.append(
+            {
+                "id": row.id,
+                "filename": row.filename,
+                "file_type": row.file_type,
+                "content_type": row.content_type,
+                "size": row.size,
+                "created_at": row.created_at,
+                "created_by": row.created_by,
+                "preview_mode": preview_mode,
+                "previewable": preview_mode != "unsupported",
+                "preview_url": f"/api/student/resources/{row.id}/preview",
+                "download_url": f"/api/student/resources/{row.id}/download",
+            }
+        )
+    payload_items.sort(key=lambda item: item.get("created_at"), reverse=True)
     return {"total": len(payload_items), "items": payload_items}
 
 
-async def get_student_resource_file_detail(resource_id: str, student_id: str):
-    main._ensure_student(student_id)
-    record = main._get_resource_or_404(resource_id)
-    main._ensure_resource_file_exists(record)
-
-    payload = main._resource_to_payload(record, route_prefix="/api/student/resources")
-    preview_mode = payload["preview_mode"]
+async def get_student_resource_file_detail(
+    resource_id: str,
+    student_id: str,
+    db: Optional[AsyncSession] = Depends(get_db),
+):
+    if db is None:
+        raise HTTPException(status_code=503, detail="PostgreSQL session unavailable")
+    await ensure_student_user(db, student_id)
+    row = await ResourceRepository(db).get(resource_id)
+    if not row or not main.os.path.exists(row.file_path):
+        raise HTTPException(status_code=404, detail="资源文件不存在")
+
+    preview_mode = _resource_preview_mode(row.file_type)
+    payload = {
+        "id": row.id,
+        "filename": row.filename,
+        "file_type": row.file_type,
+        "content_type": row.content_type,
+        "size": row.size,
+        "created_at": row.created_at,
+        "created_by": row.created_by,
+        "preview_mode": preview_mode,
+        "previewable": preview_mode != "unsupported",
+        "preview_url": f"/api/student/resources/{row.id}/preview",
+        "download_url": f"/api/student/resources/{row.id}/download",
+    }
     if preview_mode in {"markdown", "text"}:
-        payload["preview_text"] = main._read_text_preview(record.file_path)
+        payload["preview_text"] = main._read_text_preview(row.file_path)
     elif preview_mode == "docx":
-        payload["preview_text"] = main._read_docx_preview(record.file_path)
+        payload["preview_text"] = main._read_docx_preview(row.file_path)
     else:
         payload["preview_text"] = ""
     return payload
 
 
-async def preview_student_resource_file(resource_id: str, student_id: str):
-    main._ensure_student(student_id)
-    record = main._get_resource_or_404(resource_id)
-    main._ensure_resource_file_exists(record)
-
-    preview_mode = main._resource_preview_mode(record)
-    if preview_mode != "pdf":
+async def preview_student_resource_file(
+    resource_id: str,
+    student_id: str,
+    db: Optional[AsyncSession] = Depends(get_db),
+):
+    if db is None:
+        raise HTTPException(status_code=503, detail="PostgreSQL session unavailable")
+    await ensure_student_user(db, student_id)
+    row = await ResourceRepository(db).get(resource_id)
+    if not row or not main.os.path.exists(row.file_path):
+        raise HTTPException(status_code=404, detail="资源文件不存在")
+
+    if _resource_preview_mode(row.file_type) != "pdf":
         raise HTTPException(status_code=400, detail="该文件类型不支持二进制在线预览")
 
     return FileResponse(
-        path=record.file_path,
+        path=row.file_path,
         filename="document.pdf",
         media_type="application/pdf",
         content_disposition_type="inline",
     )
 
 
-async def download_student_resource_file(resource_id: str, student_id: str):
-    main._ensure_student(student_id)
-    record = main._get_resource_or_404(resource_id)
-    main._ensure_resource_file_exists(record)
-
-    media_type = record.content_type or mimetypes.guess_type(record.filename)[0] or "application/octet-stream"
+async def download_student_resource_file(
+    resource_id: str,
+    student_id: str,
+    db: Optional[AsyncSession] = Depends(get_db),
+):
+    if db is None:
+        raise HTTPException(status_code=503, detail="PostgreSQL session unavailable")
+    await ensure_student_user(db, student_id)
+    row = await ResourceRepository(db).get(resource_id)
+    if not row or not main.os.path.exists(row.file_path):
+        raise HTTPException(status_code=404, detail="资源文件不存在")
+
+    media_type = row.content_type or mimetypes.guess_type(row.filename)[0] or "application/octet-stream"
     return FileResponse(
-        path=record.file_path,
-        filename=record.filename,
+        path=row.file_path,
+        filename=row.filename,
         media_type=media_type,
         content_disposition_type="attachment",
     )
diff --git a/backend/app/api/v1/system.py b/backend/app/api/v1/system.py
index 17fe804..cbafeb0 100644
--- a/backend/app/api/v1/system.py
+++ b/backend/app/api/v1/system.py
@@ -1,26 +1,27 @@
 from datetime import datetime
 
-from fastapi import APIRouter
+from fastapi import APIRouter, Depends
 from fastapi.responses import PlainTextResponse
+from sqlalchemy.ext.asyncio import AsyncSession
 
-from ...db.session import is_postgres_ready, storage_backend_name
-from ...state import (
-    attachments_db,
-    classes_db,
-    courses_db,
-    experiments_db,
-    operation_logs_db,
-    resource_files_db,
-    resource_policy_db,
-    students_db,
+from ...db.session import get_db, is_postgres_ready, storage_backend_name
+from ...repositories import (
+    AttachmentRepository,
+    CourseRepository,
+    ExperimentRepository,
+    KVStoreRepository,
+    OperationLogRepository,
+    ResourceRepository,
+    UserRepository,
 )
+from ...services.kv_policy_service import default_resource_policy_payload
 
 router = APIRouter()
 
 
 @router.get("/")
 def root():
-    return {"message": "福州理工学院AI编程实践教学平台 API", "version": "1.0.0"}
+    return {"message": "福州理工学院AI编程实战教学平台 API", "version": "1.0.0"}
 
 
 @router.get("/api/health")
@@ -35,34 +36,50 @@ def api_health():
 
 
 @router.get("/metrics", response_class=PlainTextResponse)
-def metrics():
+async def metrics(db: AsyncSession = Depends(get_db)):
+    user_repo = UserRepository(db)
+    kv_repo = KVStoreRepository(db)
+    policy_row = await kv_repo.get("resource_policy")
+    policy = policy_row.value_json if policy_row and isinstance(policy_row.value_json, dict) else default_resource_policy_payload()
+    overrides = policy.get("overrides", {}) if isinstance(policy, dict) else {}
+    override_count = len(overrides) if isinstance(overrides, dict) else 0
+
+    students = await user_repo.list_by_role("student")
+    classes = await user_repo.list_classes()
+    courses = await CourseRepository(db).list_all()
+    experiments = await ExperimentRepository(db).list_all()
+    attachments = await AttachmentRepository(db).list_all()
+    resources = await ResourceRepository(db).list_all()
+    operation_logs = await OperationLogRepository(db).list_all()
+
     lines = [
         "# HELP training_backend_up Backend process up status (1=up).",
         "# TYPE training_backend_up gauge",
         "training_backend_up 1",
-        "# HELP training_backend_students_total Total students loaded in memory.",
+        "# HELP training_backend_students_total Total students stored in PostgreSQL.",
         "# TYPE training_backend_students_total gauge",
-        f"training_backend_students_total {len(students_db)}",
-        "# HELP training_backend_classes_total Total classes loaded in memory.",
+        f"training_backend_students_total {len(students)}",
+        "# HELP training_backend_classes_total Total classes stored in PostgreSQL.",
         "# TYPE training_backend_classes_total gauge",
-        f"training_backend_classes_total {len(classes_db)}",
-        "# HELP training_backend_courses_total Total courses loaded in memory.",
+        f"training_backend_classes_total {len(classes)}",
+        "# HELP training_backend_courses_total Total courses stored in PostgreSQL.",
         "# TYPE training_backend_courses_total gauge",
-        f"training_backend_courses_total {len(courses_db)}",
-        "# HELP training_backend_experiments_total Total experiments loaded in memory.",
+        f"training_backend_courses_total {len(courses)}",
+        "# HELP training_backend_experiments_total Total experiments stored in PostgreSQL.",
         "# TYPE training_backend_experiments_total gauge",
-        f"training_backend_experiments_total {len(experiments_db)}",
-        "# HELP training_backend_attachments_total Total attachments loaded in memory.",
+        f"training_backend_experiments_total {len(experiments)}",
+        "# HELP training_backend_attachments_total Total attachments stored in PostgreSQL.",
         "# TYPE training_backend_attachments_total gauge",
-        f"training_backend_attachments_total {len(attachments_db)}",
-        "# HELP training_backend_resources_total Total uploaded resources loaded in memory.",
+        f"training_backend_attachments_total {len(attachments)}",
+        "# HELP training_backend_resources_total Total uploaded resources stored in PostgreSQL.",
         "# TYPE training_backend_resources_total gauge",
-        f"training_backend_resources_total {len(resource_files_db)}",
-        "# HELP training_backend_resource_quota_overrides_total Total custom user resource overrides.",
+        f"training_backend_resources_total {len(resources)}",
+        "# HELP training_backend_resource_quota_overrides_total Total custom user resource overrides in PostgreSQL KV.",
         "# TYPE training_backend_resource_quota_overrides_total gauge",
-        f"training_backend_resource_quota_overrides_total {len(resource_policy_db.get('overrides', {}))}",
-        "# HELP training_backend_operation_logs_total Total operation logs retained.",
+        f"training_backend_resource_quota_overrides_total {override_count}",
+        "# HELP training_backend_operation_logs_total Total operation logs stored in PostgreSQL.",
         "# TYPE training_backend_operation_logs_total gauge",
-        f"training_backend_operation_logs_total {len(operation_logs_db)}",
+        f"training_backend_operation_logs_total {len(operation_logs)}",
     ]
     return "\n".join(lines) + "\n"
+
diff --git a/backend/app/db/session.py b/backend/app/db/session.py
index 37165eb..b289ff8 100644
--- a/backend/app/db/session.py
+++ b/backend/app/db/session.py
@@ -4,7 +4,7 @@ from typing import Optional
 from sqlalchemy import text
 from sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession, async_sessionmaker, create_async_engine
 
-from ..storage_config import DATABASE_URL, POSTGRES_SCHEMA, STORAGE_BACKEND
+from ..storage_config import DATABASE_URL, POSTGRES_SCHEMA
 
 _engine: Optional[AsyncEngine] = None
 _session_maker: Optional[async_sessionmaker[AsyncSession]] = None
@@ -76,7 +76,7 @@ def is_postgres_ready() -> bool:
 
 
 def storage_backend_name() -> str:
-    return STORAGE_BACKEND
+    return "postgres"
 
 
 async def get_db() -> AsyncGenerator[AsyncSession, None]:
diff --git a/backend/app/main.py b/backend/app/main.py
index 0a27f9f..c3eb78c 100644
--- a/backend/app/main.py
+++ b/backend/app/main.py
@@ -1,27 +1,47 @@
-?import sys
-
-from fastapi import FastAPI
+?from fastapi import FastAPI
 from fastapi.middleware.cors import CORSMiddleware
 
-from .config import APP_TITLE
-from .state import *
 from . import registry_store as _registry_store
+from .config import APP_TITLE
+from .db.session import close_db_engine, init_db_engine, init_db_schema, storage_backend_name
 from .integrations import jupyterhub_integration as _jupyterhub_integration
 from .services import ai_service as _ai_service
-from .db.session import close_db_engine, get_db, init_db_engine, init_db_schema, storage_backend_name
-from .services.postgres_state_loader import load_state_from_postgres
 
 
-def _export_module_symbols(module):
+def _export_module_symbols(
+    module,
+    *,
+    deny_prefixes: tuple[str, ...] = (),
+    deny_suffixes: tuple[str, ...] = (),
+    deny_names: set[str] | None = None,
+):
+    deny_names = deny_names or set()
     for name in dir(module):
         if name.startswith("__"):
             continue
+        if name in deny_names:
+            continue
+        if deny_prefixes and any(name.startswith(prefix) for prefix in deny_prefixes):
+            continue
+        if deny_suffixes and any(name.endswith(suffix) for suffix in deny_suffixes):
+            continue
         globals().setdefault(name, getattr(module, name))
 
 
-_export_module_symbols(_registry_store)
-_export_module_symbols(_jupyterhub_integration)
-_export_module_symbols(_ai_service)
+_export_module_symbols(
+    _registry_store,
+    deny_prefixes=("_load_", "_save_"),
+    deny_suffixes=("_db",),
+)
+_export_module_symbols(
+    _jupyterhub_integration,
+    deny_suffixes=("_db",),
+)
+_export_module_symbols(
+    _ai_service,
+    deny_prefixes=("_load_", "_save_"),
+    deny_suffixes=("_db",),
+)
 
 app = FastAPI(title=APP_TITLE)
 
@@ -36,7 +56,7 @@ app.add_middleware(
 
 @app.on_event("startup")
 async def startup_event():
-    """应用启动时加载数据。"""
+    """应用启动时仅初始化数据库连接和表结构。"""
     backend_mode = storage_backend_name()
     if backend_mode != "postgres":
         raise RuntimeError(f"Unsupported storage backend: {backend_mode!r}. Only 'postgres' is allowed.")
@@ -46,10 +66,6 @@ async def startup_event():
         raise RuntimeError("PostgreSQL initialization failed. Service exits without JSON fallback.")
 
     await init_db_schema()
-    async for db in get_db():
-        summary = await load_state_from_postgres(main_module=sys.modules[__name__], db=db)
-        print(f"[storage] Loaded runtime cache from PostgreSQL: {summary}")
-        break
 
 
 @app.on_event("shutdown")
diff --git a/backend/app/repositories/__init__.py b/backend/app/repositories/__init__.py
index 8376a99..a3ebfb1 100644
--- a/backend/app/repositories/__init__.py
+++ b/backend/app/repositories/__init__.py
@@ -1,7 +1,10 @@
 from .attachments import AttachmentRepository
 from .courses import CourseRepository
+from .kv_store import KVStoreRepository
+from .operation_logs import OperationLogRepository
 from .password_reset_repository import PasswordResetRepository
 from .experiments import ExperimentRepository
+from .resources import ResourceRepository
 from .security import PasswordHashRepository, SecurityQuestionRepository
 from .student_experiments import StudentExperimentRepository
 from .submission_pdfs import SubmissionPdfRepository
@@ -14,8 +17,11 @@ __all__ = [
     "AuthUserRepository",
     "CourseRepository",
     "ExperimentRepository",
+    "KVStoreRepository",
+    "OperationLogRepository",
     "PasswordResetRepository",
     "PasswordHashRepository",
+    "ResourceRepository",
     "SecurityQuestionRepository",
     "StudentExperimentRepository",
     "SubmissionPdfRepository",
diff --git a/backend/app/repositories/experiments.py b/backend/app/repositories/experiments.py
index 5fbeb2e..2a18f19 100644
--- a/backend/app/repositories/experiments.py
+++ b/backend/app/repositories/experiments.py
@@ -33,6 +33,11 @@ class ExperimentRepository:
         result = await self.db.execute(stmt)
         return list(result.scalars().all())
 
+    async def list_by_creator(self, created_by: str) -> Sequence[ExperimentORM]:
+        stmt = select(ExperimentORM).where(ExperimentORM.created_by == created_by)
+        result = await self.db.execute(stmt)
+        return list(result.scalars().all())
+
     async def update(self, record: ExperimentORM, payload: dict[str, Any]) -> ExperimentORM:
         for key, value in payload.items():
             setattr(record, key, value)
diff --git a/backend/app/repositories/student_experiments.py b/backend/app/repositories/student_experiments.py
index bc49ced..f9fb79e 100644
--- a/backend/app/repositories/student_experiments.py
+++ b/backend/app/repositories/student_experiments.py
@@ -1,7 +1,7 @@
 from collections.abc import Sequence
 from typing import Any
 
-from sqlalchemy import desc, select
+from sqlalchemy import delete, desc, select
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from ..db.models import StudentExperimentORM
@@ -73,3 +73,17 @@ class StudentExperimentRepository:
         if record is None:
             return await self.create(payload)
         return await self.update(record, payload)
+
+    async def delete(self, student_experiment_id: str) -> StudentExperimentORM | None:
+        record = await self.get(student_experiment_id)
+        if record is None:
+            return None
+        await self.db.delete(record)
+        return record
+
+    async def delete_by_student(self, student_id: str) -> int:
+        normalized = str(student_id or "").strip()
+        if not normalized:
+            return 0
+        result = await self.db.execute(delete(StudentExperimentORM).where(StudentExperimentORM.student_id == normalized))
+        return int(result.rowcount or 0)
diff --git a/backend/app/repositories/submission_pdfs.py b/backend/app/repositories/submission_pdfs.py
index 02bcc6b..bbc67b7 100644
--- a/backend/app/repositories/submission_pdfs.py
+++ b/backend/app/repositories/submission_pdfs.py
@@ -1,7 +1,7 @@
 from collections.abc import Sequence
 from typing import Any
 
-from sqlalchemy import select
+from sqlalchemy import delete, select
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from ..db.models import SubmissionPdfORM
@@ -30,6 +30,11 @@ class SubmissionPdfRepository:
         result = await self.db.execute(stmt)
         return list(result.scalars().all())
 
+    async def list_by_student(self, student_id: str) -> Sequence[SubmissionPdfORM]:
+        stmt = select(SubmissionPdfORM).where(SubmissionPdfORM.student_id == student_id)
+        result = await self.db.execute(stmt)
+        return list(result.scalars().all())
+
     async def update(self, record: SubmissionPdfORM, payload: dict[str, Any]) -> SubmissionPdfORM:
         for key, value in payload.items():
             setattr(record, key, value)
@@ -43,3 +48,17 @@ class SubmissionPdfRepository:
         if record is None:
             return await self.create(payload)
         return await self.update(record, payload)
+
+    async def delete(self, pdf_id: str) -> SubmissionPdfORM | None:
+        record = await self.get(pdf_id)
+        if record is None:
+            return None
+        await self.db.delete(record)
+        return record
+
+    async def delete_by_student(self, student_id: str) -> int:
+        normalized = str(student_id or "").strip()
+        if not normalized:
+            return 0
+        result = await self.db.execute(delete(SubmissionPdfORM).where(SubmissionPdfORM.student_id == normalized))
+        return int(result.rowcount or 0)
diff --git a/backend/app/repositories/user_repository.py b/backend/app/repositories/user_repository.py
index a9c197f..62ca860 100644
--- a/backend/app/repositories/user_repository.py
+++ b/backend/app/repositories/user_repository.py
@@ -86,3 +86,22 @@ class AuthUserRepository:
                 value = self._normalize_text(value) or None
             setattr(record, key, value)
         return record, created
+
+    async def list_all(self) -> list[AuthUserORM]:
+        result = await self.db.execute(select(AuthUserORM))
+        return list(result.scalars().all())
+
+    async def list_by_role(self, role: str) -> list[AuthUserORM]:
+        normalized = self._normalize_text(role).lower()
+        if not normalized:
+            return []
+        stmt = select(AuthUserORM).where(AuthUserORM.role == normalized)
+        result = await self.db.execute(stmt)
+        return list(result.scalars().all())
+
+    async def delete_by_username(self, username: str) -> bool:
+        record = await self.get_by_username(username)
+        if record is None:
+            return False
+        await self.db.delete(record)
+        return True
diff --git a/backend/app/repositories/users.py b/backend/app/repositories/users.py
index d6eb3f0..33739a7 100644
--- a/backend/app/repositories/users.py
+++ b/backend/app/repositories/users.py
@@ -1,7 +1,7 @@
 from collections.abc import Sequence
 from typing import Any
 
-from sqlalchemy import select
+from sqlalchemy import func, select
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from ..db.models import ClassroomORM, UserORM
@@ -85,3 +85,16 @@ class UserRepository:
     async def list_classes(self) -> Sequence[ClassroomORM]:
         result = await self.db.execute(select(ClassroomORM))
         return list(result.scalars().all())
+
+    async def list_classes_by_creator(self, created_by: str) -> Sequence[ClassroomORM]:
+        stmt = select(ClassroomORM).where(ClassroomORM.created_by == created_by)
+        result = await self.db.execute(stmt)
+        return list(result.scalars().all())
+
+    async def get_class_by_name(self, class_name: str) -> ClassroomORM | None:
+        normalized_name = str(class_name or "").strip().lower()
+        if not normalized_name:
+            return None
+        stmt = select(ClassroomORM).where(func.lower(ClassroomORM.name) == normalized_name)
+        result = await self.db.execute(stmt)
+        return result.scalars().first()
diff --git a/backend/app/services/ai_service.py b/backend/app/services/ai_service.py
index 0ac2ff6..c09874b 100644
--- a/backend/app/services/ai_service.py
+++ b/backend/app/services/ai_service.py
@@ -21,8 +21,6 @@ except Exception:
 from ..config import (
     DEFAULT_AI_SHARED_CONFIG,
     AI_RESPONSE_STYLE_RULES,
-    AI_SHARED_CONFIG_FILE,
-    AI_CHAT_HISTORY_FILE,
     AI_CHAT_HISTORY_MAX_MESSAGES,
     AI_CHAT_HISTORY_MAX_MESSAGE_CHARS,
     AI_CONTEXT_MAX_HISTORY_MESSAGES,
@@ -140,26 +138,20 @@ def _normalize_ai_shared_config(raw: Optional[dict]) -> dict:
     }
 
 
-def _save_ai_shared_config():
-    tmp_path = f"{AI_SHARED_CONFIG_FILE}.tmp"
-    with open(tmp_path, "w", encoding="utf-8") as file_obj:
-        json.dump(ai_shared_config_db, file_obj, ensure_ascii=False, indent=2)
-    os.replace(tmp_path, AI_SHARED_CONFIG_FILE)
+def _refresh_ai_shared_config_cache(raw: Optional[dict]) -> dict:
+    normalized = dict(DEFAULT_AI_SHARED_CONFIG)
+    normalized.update(_normalize_ai_shared_config(raw))
+    ai_shared_config_db.clear()
+    ai_shared_config_db.update(normalized)
+    return normalized
 
 
-def _load_ai_shared_config():
-    ai_shared_config_db.clear()
-    ai_shared_config_db.update(DEFAULT_AI_SHARED_CONFIG)
+def _save_ai_shared_config():
+    _refresh_ai_shared_config_cache(ai_shared_config_db)
 
-    if not os.path.exists(AI_SHARED_CONFIG_FILE):
-        return
 
-    try:
-        with open(AI_SHARED_CONFIG_FILE, "r", encoding="utf-8") as file_obj:
-            payload = json.load(file_obj) or {}
-        ai_shared_config_db.update(_normalize_ai_shared_config(payload))
-    except Exception as exc:
-        print(f"Failed to load ai shared config: {exc}")
+def _load_ai_shared_config():
+    _refresh_ai_shared_config_cache(None)
 
 
 def _normalize_chat_history_message(raw: Optional[dict]) -> Optional[Dict[str, str]]:
@@ -196,33 +188,12 @@ def _save_ai_chat_history():
         if not normalized_username:
             continue
         payload[normalized_username] = _normalize_chat_history_items(items)
-
-    tmp_path = f"{AI_CHAT_HISTORY_FILE}.tmp"
-    with open(tmp_path, "w", encoding="utf-8") as file_obj:
-        json.dump(payload, file_obj, ensure_ascii=False, indent=2)
-    os.replace(tmp_path, AI_CHAT_HISTORY_FILE)
+    ai_chat_history_db.clear()
+    ai_chat_history_db.update(payload)
 
 
 def _load_ai_chat_history():
     ai_chat_history_db.clear()
-    if not os.path.exists(AI_CHAT_HISTORY_FILE):
-        return
-
-    try:
-        with open(AI_CHAT_HISTORY_FILE, "r", encoding="utf-8") as file_obj:
-            payload = json.load(file_obj) or {}
-    except Exception as exc:
-        print(f"Failed to load ai chat history: {exc}")
-        return
-
-    if not isinstance(payload, dict):
-        return
-
-    for username, items in payload.items():
-        normalized_username = _normalize_text(username)
-        if not normalized_username:
-            continue
-        ai_chat_history_db[normalized_username] = _normalize_chat_history_items(items)
 
 
 def _get_ai_chat_history(username: str) -> List[Dict[str, str]]:
diff --git a/backend/app/services/attachment_service.py b/backend/app/services/attachment_service.py
index 3fafb20..d22346d 100644
--- a/backend/app/services/attachment_service.py
+++ b/backend/app/services/attachment_service.py
@@ -14,12 +14,12 @@ from ..repositories import AttachmentRepository, ExperimentRepository
 
 class AttachmentService:
     def __init__(self, main_module, db: Optional[AsyncSession] = None):
+        if db is None:
+            raise HTTPException(status_code=503, detail="PostgreSQL session unavailable")
         self.main = main_module
         self.db = db
 
     async def _commit(self):
-        if self.db is None:
-            return
         try:
             await self.db.commit()
         except Exception as exc:
@@ -39,29 +39,6 @@ class AttachmentService:
         )
 
     async def upload_attachments(self, experiment_id: str, files: list[UploadFile]):
-        if self.db is None:
-            if experiment_id not in self.main.experiments_db:
-                raise HTTPException(status_code=404, detail="实验不存在")
-            uploaded = []
-            for file in files:
-                att_id = str(uuid.uuid4())
-                safe_filename = file.filename.replace(" ", "_")
-                file_path = os.path.join(self.main.UPLOAD_DIR, f"{att_id}_{safe_filename}")
-                with open(file_path, "wb") as buffer:
-                    shutil.copyfileobj(file.file, buffer)
-                attachment = self.main.Attachment(
-                    id=att_id,
-                    experiment_id=experiment_id,
-                    filename=file.filename,
-                    file_path=file_path,
-                    content_type=file.content_type or "application/octet-stream",
-                    size=os.path.getsize(file_path),
-                    created_at=datetime.now(),
-                )
-                self.main.attachments_db[att_id] = attachment
-                uploaded.append(attachment)
-            return uploaded
-
         experiment = await ExperimentRepository(self.db).get(experiment_id)
         if not experiment:
             raise HTTPException(status_code=404, detail="实验不存在")
@@ -104,34 +81,51 @@ class AttachmentService:
                         pass
             raise HTTPException(status_code=500, detail=f"保存附件失败: {exc}") from exc
 
-        for item in uploaded:
-            self.main.attachments_db[item.id] = item
         return uploaded
 
     async def list_attachments(self, experiment_id: str):
-        if self.db is None:
-            return [att for att in self.main.attachments_db.values() if att.experiment_id == experiment_id]
-
         rows = await AttachmentRepository(self.db).list_by_experiment(experiment_id)
-        items = [self._to_model(self.main, row) for row in rows]
-        for item in items:
-            self.main.attachments_db[item.id] = item
-        return items
+        return [self._to_model(self.main, row) for row in rows]
 
     async def get_attachment(self, attachment_id: str):
-        if self.db is None:
-            item = self.main.attachments_db.get(attachment_id)
-            if not item:
-                raise HTTPException(status_code=404, detail="附件不存在")
-            return item
+        row = await AttachmentRepository(self.db).get(attachment_id)
+        if not row:
+            raise HTTPException(status_code=404, detail="附件不存在")
+        return self._to_model(self.main, row)
 
+    async def find_paired_word_attachment(self, attachment_id: str):
         row = await AttachmentRepository(self.db).get(attachment_id)
         if not row:
             raise HTTPException(status_code=404, detail="附件不存在")
-        item = self._to_model(self.main, row)
-        self.main.attachments_db[item.id] = item
-        return item
+
+        lower_filename = row.filename.lower()
+        is_pdf = row.content_type == "application/pdf" or lower_filename.endswith(".pdf")
+        if not is_pdf:
+            return self._to_model(self.main, row)
+
+        base_name = os.path.splitext(row.filename)[0]
+        candidates = await AttachmentRepository(self.db).list_by_experiment(row.experiment_id)
+        matched = []
+        for item in candidates:
+            item_base = os.path.splitext(item.filename)[0]
+            item_lower = item.filename.lower()
+            if item.id == row.id:
+                continue
+            if item_base != base_name:
+                continue
+            if not (item_lower.endswith(".docx") or item_lower.endswith(".doc")):
+                continue
+            if not os.path.exists(item.file_path):
+                continue
+            matched.append(item)
+
+        if not matched:
+            return self._to_model(self.main, row)
+
+        matched.sort(key=lambda item: 0 if item.filename.lower().endswith(".docx") else 1)
+        return self._to_model(self.main, matched[0])
 
 
 def build_attachment_service(main_module, db: Optional[AsyncSession] = None) -> AttachmentService:
     return AttachmentService(main_module=main_module, db=db)
+
diff --git a/backend/app/services/experiment_service.py b/backend/app/services/experiment_service.py
index ae9ded9..815df5d 100644
--- a/backend/app/services/experiment_service.py
+++ b/backend/app/services/experiment_service.py
@@ -1,4 +1,7 @@
-?from datetime import datetime
+from __future__ import annotations
+
+import uuid
+from datetime import datetime
 from typing import Optional
 
 from fastapi import HTTPException
@@ -6,6 +9,7 @@ from sqlalchemy.exc import SQLAlchemyError
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from ..repositories import AttachmentRepository, CourseRepository, ExperimentRepository, UserRepository
+from .identity_service import ensure_teacher_or_admin, normalize_text, resolve_user_role
 
 
 class ExperimentService:
@@ -21,16 +25,6 @@ class ExperimentService:
             return value
         return fallback
 
-    def _to_course_record(self, row):
-        return self.main.CourseRecord(
-            id=row.id,
-            name=row.name,
-            description=row.description or "",
-            created_by=row.created_by,
-            created_at=row.created_at,
-            updated_at=row.updated_at,
-        )
-
     def _to_student_record(self, row):
         student_id = row.student_id or row.username
         return self.main.StudentRecord(
@@ -65,7 +59,7 @@ class ExperimentService:
         return self.main.Experiment(
             id=row.id,
             course_id=row.course_id,
-            course_name=row.course_name,
+            course_name=row.course_name or "",
             title=row.title,
             description=row.description or None,
             difficulty=difficulty,
@@ -81,6 +75,21 @@ class ExperimentService:
             target_student_ids=list(row.target_student_ids or []),
         )
 
+    @staticmethod
+    def _resolve_course_name(experiment) -> str:
+        explicit = normalize_text(getattr(experiment, "course_name", ""))
+        if explicit:
+            return explicit
+        notebook_path = normalize_text(getattr(experiment, "notebook_path", ""))
+        first_segment = next((seg for seg in notebook_path.split("/") if seg), "")
+        if first_segment and first_segment.lower() != "course":
+            return first_segment
+        return "Python程序设计"
+
+    def _normalize_publish_targets(self, experiment):
+        self.main._normalize_experiment_publish_targets(experiment)
+        self.main._validate_experiment_publish_targets(experiment)
+
     def _to_experiment_payload(self, experiment: "Experiment") -> dict:
         now = datetime.now()
         created_at = self._safe_datetime(experiment.created_at, now)
@@ -105,17 +114,6 @@ class ExperimentService:
             "extra": {},
         }
 
-    def _to_course_payload(self, course) -> dict:
-        now = datetime.now()
-        return {
-            "id": course.id,
-            "name": course.name,
-            "description": course.description or "",
-            "created_by": course.created_by,
-            "created_at": self._safe_datetime(course.created_at, now),
-            "updated_at": self._safe_datetime(course.updated_at, now),
-        }
-
     async def _commit_pg(self):
         try:
             await self.db.commit()
@@ -130,26 +128,26 @@ class ExperimentService:
         requested_course_id: Optional[str] = None,
     ):
         repo = CourseRepository(self.db)
-        normalized_teacher = self.main._normalize_text(teacher_username)
-        normalized_name = self.main._normalize_text(course_name) or "Python程序设计"
-        normalized_requested_id = self.main._normalize_text(requested_course_id)
+        normalized_teacher = normalize_text(teacher_username)
+        normalized_name = normalize_text(course_name) or "Python程序设计"
+        normalized_requested_id = normalize_text(requested_course_id)
 
         if normalized_requested_id:
             course = await repo.get(normalized_requested_id)
             if not course:
                 raise HTTPException(status_code=404, detail="课程不存在")
-            if self.main._normalize_text(course.created_by) != normalized_teacher:
+            if normalize_text(course.created_by) != normalized_teacher:
                 raise HTTPException(status_code=403, detail="不能使用其他教师创建的课程")
-            return course, False
+            return course
 
         existing = await repo.find_by_teacher_and_name(normalized_teacher, normalized_name)
         if existing:
-            return existing, False
+            return existing
 
         now = datetime.now()
         created = await repo.create(
             {
-                "id": str(self.main.uuid.uuid4()),
+                "id": str(uuid.uuid4()),
                 "name": normalized_name,
                 "description": "",
                 "created_by": normalized_teacher,
@@ -157,7 +155,7 @@ class ExperimentService:
                 "updated_at": now,
             }
         )
-        return created, True
+        return created
 
     async def _find_student_row(self, username: str):
         repo = UserRepository(self.db)
@@ -168,37 +166,42 @@ class ExperimentService:
         user = await repo.get_by_username(username)
         if user is None:
             return None
-        if self.main._normalize_text(user.role).lower() != "student":
+        if normalize_text(user.role).lower() != "student":
             return None
         return user
 
     async def create_experiment(self, experiment: "Experiment"):
-        normalized_teacher = self.main._normalize_text(experiment.created_by)
-        self.main._ensure_teacher(normalized_teacher)
+        normalized_teacher = normalize_text(experiment.created_by)
+        await ensure_teacher_or_admin(self.db, normalized_teacher)
         experiment.created_by = normalized_teacher
 
-        course_row, _ = await self._resolve_or_create_teacher_course_pg(
+        course_row = await self._resolve_or_create_teacher_course_pg(
             normalized_teacher,
-            self.main._resolve_course_name(experiment),
+            self._resolve_course_name(experiment),
             experiment.course_id,
         )
 
-        experiment.id = str(self.main.uuid.uuid4())
+        experiment.id = str(uuid.uuid4())
         experiment.created_at = datetime.now()
         experiment.course_id = course_row.id
         experiment.course_name = course_row.name
-        self.main._normalize_experiment_publish_targets(experiment)
-        self.main._validate_experiment_publish_targets(experiment)
+        self._normalize_publish_targets(experiment)
 
         course_row.updated_at = experiment.created_at
         course_repo = CourseRepository(self.db)
         experiment_repo = ExperimentRepository(self.db)
-        await course_repo.upsert(self._to_course_payload(course_row))
+        await course_repo.upsert(
+            {
+                "id": course_row.id,
+                "name": course_row.name,
+                "description": course_row.description or "",
+                "created_by": course_row.created_by,
+                "created_at": course_row.created_at,
+                "updated_at": course_row.updated_at,
+            }
+        )
         await experiment_repo.upsert(self._to_experiment_payload(experiment))
         await self._commit_pg()
-
-        self.main.courses_db[course_row.id] = self._to_course_record(course_row)
-        self.main.experiments_db[experiment.id] = experiment
         return experiment
 
     async def list_experiments(
@@ -211,26 +214,21 @@ class ExperimentService:
         rows = await experiment_repo.list_all()
         experiments = [self._to_experiment_model(item) for item in rows]
 
-        self.main.experiments_db.clear()
-        for item in experiments:
-            if item.id:
-                self.main.experiments_db[item.id] = item
-
-        normalized_username = self.main._normalize_text(username)
-        if normalized_username and not (self.main.is_teacher(normalized_username) or self.main.is_admin(normalized_username)):
-            student_row = await self._find_student_row(normalized_username)
-            if not student_row:
-                experiments = []
-            else:
-                student = self._to_student_record(student_row)
-                experiments = [e for e in experiments if self.main._is_experiment_visible_to_student(e, student)]
+        normalized_username = normalize_text(username)
+        if normalized_username:
+            role = await resolve_user_role(self.db, normalized_username)
+            if role not in {"teacher", "admin"}:
+                student_row = await self._find_student_row(normalized_username)
+                if not student_row:
+                    experiments = []
+                else:
+                    student = self._to_student_record(student_row)
+                    experiments = [e for e in experiments if self.main._is_experiment_visible_to_student(e, student)]
 
         if difficulty:
             experiments = [e for e in experiments if e.difficulty == difficulty]
-
         if tag:
             experiments = [e for e in experiments if tag in e.tags]
-
         return experiments
 
     async def get_experiment(self, experiment_id: str):
@@ -238,13 +236,13 @@ class ExperimentService:
         row = await experiment_repo.get(experiment_id)
         if not row:
             raise HTTPException(status_code=404, detail="实验不存在")
-        model = self._to_experiment_model(row)
-        if model.id:
-            self.main.experiments_db[model.id] = model
-        return model
+        return self._to_experiment_model(row)
 
     async def update_experiment(self, experiment_id: str, experiment: "Experiment"):
-        existing = await self.get_experiment(experiment_id)
+        existing_row = await ExperimentRepository(self.db).get(experiment_id)
+        if not existing_row:
+            raise HTTPException(status_code=404, detail="实验不存在")
+        existing = self._to_experiment_model(existing_row)
 
         experiment.id = experiment_id
         if experiment.created_at is None:
@@ -252,16 +250,16 @@ class ExperimentService:
         if not experiment.created_by:
             experiment.created_by = existing.created_by
 
-        normalized_teacher = self.main._normalize_text(experiment.created_by)
-        self.main._ensure_teacher(normalized_teacher)
+        normalized_teacher = normalize_text(experiment.created_by)
+        await ensure_teacher_or_admin(self.db, normalized_teacher)
         experiment.created_by = normalized_teacher
 
         requested_course_id = experiment.course_id or existing.course_id
-        requested_course_name = self.main._resolve_course_name(experiment)
-        if not self.main._normalize_text(experiment.course_name):
-            requested_course_name = self.main._resolve_course_name(existing)
+        requested_course_name = self._resolve_course_name(experiment)
+        if not normalize_text(experiment.course_name):
+            requested_course_name = self._resolve_course_name(existing)
 
-        course_row, _ = await self._resolve_or_create_teacher_course_pg(
+        course_row = await self._resolve_or_create_teacher_course_pg(
             normalized_teacher,
             requested_course_name,
             requested_course_id,
@@ -269,18 +267,23 @@ class ExperimentService:
 
         experiment.course_id = course_row.id
         experiment.course_name = course_row.name
-        self.main._normalize_experiment_publish_targets(experiment)
-        self.main._validate_experiment_publish_targets(experiment)
+        self._normalize_publish_targets(experiment)
 
         course_row.updated_at = datetime.now()
         course_repo = CourseRepository(self.db)
         experiment_repo = ExperimentRepository(self.db)
-        await course_repo.upsert(self._to_course_payload(course_row))
+        await course_repo.upsert(
+            {
+                "id": course_row.id,
+                "name": course_row.name,
+                "description": course_row.description or "",
+                "created_by": course_row.created_by,
+                "created_at": course_row.created_at,
+                "updated_at": course_row.updated_at,
+            }
+        )
         await experiment_repo.upsert(self._to_experiment_payload(experiment))
         await self._commit_pg()
-
-        self.main.courses_db[course_row.id] = self._to_course_record(course_row)
-        self.main.experiments_db[experiment_id] = experiment
         return experiment
 
     async def delete_experiment(self, experiment_id: str):
@@ -292,10 +295,8 @@ class ExperimentService:
         if existing is None:
             raise HTTPException(status_code=404, detail="实验不存在")
 
-        removed_exp = self._to_experiment_model(existing)
         attachments = await attachment_repo.list_by_experiment(experiment_id)
         removed_attachment_ids = [item.id for item in attachments]
-
         for item in attachments:
             if item.file_path and self.main.os.path.exists(item.file_path):
                 try:
@@ -307,20 +308,14 @@ class ExperimentService:
             await attachment_repo.delete_many(removed_attachment_ids)
         await experiment_repo.delete(experiment_id)
 
-        course_id = self.main._normalize_text(removed_exp.course_id)
+        course_id = normalize_text(existing.course_id)
         if course_id:
             await course_repo.touch(course_id, datetime.now())
 
         await self._commit_pg()
-
-        self.main.experiments_db.pop(experiment_id, None)
-        for att_id in removed_attachment_ids:
-            self.main.attachments_db.pop(att_id, None)
-        if course_id and course_id in self.main.courses_db:
-            self.main.courses_db[course_id].updated_at = datetime.now()
-
         return {"message": "实验已删除"}
 
 
 def build_experiment_service(main_module, db: Optional[AsyncSession] = None) -> ExperimentService:
     return ExperimentService(main_module=main_module, db=db)
+
diff --git a/backend/app/services/student_service.py b/backend/app/services/student_service.py
index d940e81..8584b39 100644
--- a/backend/app/services/student_service.py
+++ b/backend/app/services/student_service.py
@@ -1,23 +1,23 @@
 from __future__ import annotations
 
-import uuid
 from datetime import datetime
 from typing import Optional
 
 from fastapi import HTTPException
 from sqlalchemy.ext.asyncio import AsyncSession
 
-from ..repositories import ExperimentRepository, StudentExperimentRepository, UserRepository
+from ..repositories import AuthUserRepository, ExperimentRepository, StudentExperimentRepository, UserRepository
+from .identity_service import ensure_student_user, normalize_text
 
 
 class StudentService:
     def __init__(self, main_module, db: Optional[AsyncSession] = None):
+        if db is None:
+            raise HTTPException(status_code=503, detail="PostgreSQL session unavailable")
         self.main = main_module
         self.db = db
 
     async def _commit(self):
-        if self.db is None:
-            return
         try:
             await self.db.commit()
         except Exception as exc:
@@ -92,49 +92,36 @@ class StudentService:
             teacher_comment=row.teacher_comment or "",
         )
 
+    async def _update_auth_password(self, username: str, new_hash: str):
+        auth_repo = AuthUserRepository(self.db)
+        auth_user = await auth_repo.get_by_login_identifier(username)
+        if auth_user is not None:
+            auth_user.password_hash = new_hash
+            auth_user.updated_at = datetime.now()
+
     async def get_student_courses_with_status(self, student_id: str):
-        normalized_student_id = self.main._normalize_text(student_id)
+        normalized_student_id = normalize_text(student_id)
         if not normalized_student_id:
             raise HTTPException(status_code=404, detail="学生不存在")
 
-        if self.db is None:
-            self.main._ensure_student(normalized_student_id)
-            student = self.main.students_db[normalized_student_id]
-            published_courses = [
-                exp
-                for exp in self.main.experiments_db.values()
-                if self.main._is_experiment_visible_to_student(exp, student)
-            ]
-            student_records = {
-                exp.experiment_id: exp
-                for exp in self.main.student_experiments_db.values()
-                if exp.student_id == normalized_student_id
-            }
-        else:
-            user_repo = UserRepository(self.db)
-            student_row = await user_repo.get_student_by_student_id(normalized_student_id)
-            if not student_row:
-                raise HTTPException(status_code=404, detail="学生不存在")
-            student = self._to_student_record(student_row)
-
-            exp_rows = await ExperimentRepository(self.db).list_all()
-            published_courses = []
-            for row in exp_rows:
-                exp_model = self._to_experiment_model(row)
-                if self.main._is_experiment_visible_to_student(exp_model, student):
-                    published_courses.append(exp_model)
-                    self.main.experiments_db[exp_model.id] = exp_model
-
-            se_rows = await StudentExperimentRepository(self.db).list_by_student(normalized_student_id)
-            student_records = {}
-            for row in se_rows:
-                item = self._to_student_experiment_model(row)
-                student_records[item.experiment_id] = item
-                self.main.student_experiments_db[item.id] = item
-            self.main.students_db[student.student_id] = student
+        student_row = await ensure_student_user(self.db, normalized_student_id)
+        student = self._to_student_record(student_row)
+
+        exp_rows = await ExperimentRepository(self.db).list_all()
+        visible_courses = []
+        for row in exp_rows:
+            exp_model = self._to_experiment_model(row)
+            if self.main._is_experiment_visible_to_student(exp_model, student):
+                visible_courses.append(exp_model)
+
+        se_rows = await StudentExperimentRepository(self.db).list_by_student(student.student_id)
+        student_records = {}
+        for row in se_rows:
+            item = self._to_student_experiment_model(row)
+            student_records[item.experiment_id] = item
 
         courses_with_status = []
-        for course in published_courses:
+        for course in visible_courses:
             record = student_records.get(course.id)
             courses_with_status.append(
                 {
@@ -149,27 +136,8 @@ class StudentService:
         return courses_with_status
 
     async def get_student_profile(self, student_id: str):
-        if self.db is None:
-            student = self.main.students_db.get(student_id)
-            if not student:
-                raise HTTPException(status_code=404, detail="学生不存在")
-            return {
-                "student_id": student.student_id,
-                "real_name": student.real_name,
-                "class_name": student.class_name,
-                "organization": student.organization,
-                "major": student.organization,
-                "admission_year": self.main._normalize_admission_year(student.admission_year),
-                "admission_year_label": self.main._format_admission_year_label(student.admission_year),
-                "security_question": self.main._normalize_security_question(student.security_question or ""),
-                "security_question_set": bool(self.main._normalize_security_question(student.security_question or "")),
-            }
-
-        row = await UserRepository(self.db).get_student_by_student_id(student_id)
-        if not row:
-            raise HTTPException(status_code=404, detail="学生不存在")
+        row = await ensure_student_user(self.db, student_id)
         student = self._to_student_record(row)
-        self.main.students_db[student.student_id] = student
         return {
             "student_id": student.student_id,
             "real_name": student.real_name,
@@ -183,7 +151,7 @@ class StudentService:
         }
 
     async def upsert_student_security_question(self, payload):
-        student_id = self.main._normalize_text(payload.student_id)
+        student_id = normalize_text(payload.student_id)
         question = self.main._normalize_security_question(payload.security_question or "")
         answer = payload.security_answer or ""
 
@@ -194,15 +162,6 @@ class StudentService:
         if len(self.main._normalize_security_answer(answer)) < 2:
             raise HTTPException(status_code=400, detail="密保答案至少2个字符")
 
-        if self.db is None:
-            student = self.main.students_db.get(student_id)
-            if not student:
-                raise HTTPException(status_code=404, detail="学生不存在")
-            student.security_question = question
-            student.security_answer_hash = self.main._hash_security_answer(answer)
-            student.updated_at = datetime.now()
-            return {"message": "密保问题已保存"}
-
         repo = UserRepository(self.db)
         student = await repo.get_student_by_student_id(student_id)
         if not student:
@@ -211,12 +170,10 @@ class StudentService:
         student.security_answer_hash = self.main._hash_security_answer(answer)
         student.updated_at = datetime.now()
         await self._commit()
-
-        self.main.students_db[student_id] = self._to_student_record(student)
         return {"message": "密保问题已保存"}
 
     async def change_student_password(self, payload):
-        student_id = self.main._normalize_text(payload.student_id)
+        student_id = normalize_text(payload.student_id)
         old_password = payload.old_password or ""
         new_password = payload.new_password or ""
 
@@ -227,16 +184,6 @@ class StudentService:
         if old_password == new_password:
             raise HTTPException(status_code=400, detail="新密码不能与旧密码相同")
 
-        if self.db is None:
-            student = self.main.students_db.get(student_id)
-            if not student:
-                raise HTTPException(status_code=404, detail="学生不存在")
-            if student.password_hash != self.main._hash_password(old_password):
-                raise HTTPException(status_code=401, detail="旧密码错误")
-            student.password_hash = self.main._hash_password(new_password)
-            student.updated_at = datetime.now()
-            return {"message": "密码修改成功"}
-
         repo = UserRepository(self.db)
         student = await repo.get_student_by_student_id(student_id)
         if not student:
@@ -244,12 +191,14 @@ class StudentService:
         if student.password_hash != self.main._hash_password(old_password):
             raise HTTPException(status_code=401, detail="旧密码错误")
 
-        student.password_hash = self.main._hash_password(new_password)
+        new_hash = self.main._hash_password(new_password)
+        student.password_hash = new_hash
         student.updated_at = datetime.now()
+        await self._update_auth_password(student.username or student.student_id, new_hash)
         await self._commit()
-        self.main.students_db[student_id] = self._to_student_record(student)
         return {"message": "密码修改成功"}
 
 
 def build_student_service(main_module, db: Optional[AsyncSession] = None) -> StudentService:
     return StudentService(main_module=main_module, db=db)
+
diff --git a/backend/app/services/submission_service.py b/backend/app/services/submission_service.py
index 7b2eb64..0e93d05 100644
--- a/backend/app/services/submission_service.py
+++ b/backend/app/services/submission_service.py
@@ -16,16 +16,17 @@ from ..repositories import (
     SubmissionPdfRepository,
     UserRepository,
 )
+from .identity_service import ensure_teacher_or_admin, normalize_text, resolve_user_role
 
 
 class SubmissionService:
     def __init__(self, main_module, db: Optional[AsyncSession] = None):
+        if db is None:
+            raise HTTPException(status_code=503, detail="PostgreSQL session unavailable")
         self.main = main_module
         self.db = db
 
     async def _commit(self):
-        if self.db is None:
-            return
         try:
             await self.db.commit()
         except Exception as exc:
@@ -104,8 +105,8 @@ class SubmissionService:
         if row.reviewed:
             return "已批阅"
         if row.viewed:
-            return "已查阅"
-        return "未查阅"
+            return "已查看"
+        return "未查看"
 
     def _pdf_to_payload(self, row) -> dict:
         annotations = []
@@ -140,40 +141,26 @@ class SubmissionService:
             "annotations": annotations,
         }
 
+    async def _ensure_teacher(self, username: str) -> str:
+        normalized, _ = await ensure_teacher_or_admin(self.db, username)
+        return normalized
+
     async def start_experiment(self, experiment_id: str, student_id: str):
-        student_id = self.main._normalize_text(student_id)
+        student_id = normalize_text(student_id)
         if not student_id:
             raise HTTPException(status_code=400, detail="student_id不能为空")
 
-        if self.db is None:
-            if experiment_id not in self.main.experiments_db:
-                raise HTTPException(status_code=404, detail="实验不存在")
-            self.main._ensure_student(student_id)
-            experiment = self.main.experiments_db[experiment_id]
-            student = self.main.students_db[student_id]
-            student_exp = max(
-                [
-                    exp
-                    for exp in self.main.student_experiments_db.values()
-                    if exp.student_id == student_id and exp.experiment_id == experiment_id
-                ],
-                key=lambda item: item.start_time or datetime.min,
-                default=None,
-            )
-        else:
-            exp_row = await ExperimentRepository(self.db).get(experiment_id)
-            if not exp_row:
-                raise HTTPException(status_code=404, detail="实验不存在")
-            student_row = await UserRepository(self.db).get_student_by_student_id(student_id)
-            if not student_row:
-                raise HTTPException(status_code=404, detail="学生不存在")
-            experiment = self._to_experiment_model(exp_row)
-            student = self._to_student_record(student_row)
-            self.main.experiments_db[experiment.id] = experiment
-            self.main.students_db[student.student_id] = student
-
-            existing = await StudentExperimentRepository(self.db).get_by_student_and_experiment(student_id, experiment_id)
-            student_exp = self._to_student_experiment_model(existing) if existing else None
+        exp_row = await ExperimentRepository(self.db).get(experiment_id)
+        if not exp_row:
+            raise HTTPException(status_code=404, detail="实验不存在")
+        student_row = await UserRepository(self.db).get_student_by_student_id(student_id)
+        if not student_row:
+            raise HTTPException(status_code=404, detail="学生不存在")
+
+        experiment = self._to_experiment_model(exp_row)
+        student = self._to_student_record(student_row)
+        existing = await StudentExperimentRepository(self.db).get_by_student_and_experiment(student_id, experiment_id)
+        student_exp = self._to_student_experiment_model(existing) if existing else None
 
         if not self.main._is_experiment_visible_to_student(experiment, student):
             raise HTTPException(status_code=403, detail="该实验当前未发布给你")
@@ -182,36 +169,23 @@ class SubmissionService:
         notebook_relpath = f"work/{user_notebook_name}"
 
         if student_exp is None:
-            record_id = str(uuid.uuid4())
-            if self.db is None:
-                student_exp = self.main.StudentExperiment(
-                    id=record_id,
-                    experiment_id=experiment_id,
-                    student_id=student_id,
-                    status=self.main.ExperimentStatus.IN_PROGRESS,
-                    start_time=datetime.now(),
-                    notebook_content=user_notebook_name,
-                )
-                self.main.student_experiments_db[student_exp.id] = student_exp
-            else:
-                payload = {
-                    "id": record_id,
-                    "experiment_id": experiment_id,
-                    "student_id": student_id,
-                    "status": self.main.ExperimentStatus.IN_PROGRESS.value,
-                    "start_time": datetime.now(),
-                    "notebook_content": user_notebook_name,
-                    "submit_time": None,
-                    "score": None,
-                    "ai_feedback": "",
-                    "teacher_comment": "",
-                    "created_at": datetime.now(),
-                    "updated_at": datetime.now(),
-                }
-                row = await StudentExperimentRepository(self.db).create(payload)
-                await self._commit()
-                student_exp = self._to_student_experiment_model(row)
-                self.main.student_experiments_db[student_exp.id] = student_exp
+            payload = {
+                "id": str(uuid.uuid4()),
+                "experiment_id": experiment_id,
+                "student_id": student_id,
+                "status": self.main.ExperimentStatus.IN_PROGRESS.value,
+                "start_time": datetime.now(),
+                "notebook_content": user_notebook_name,
+                "submit_time": None,
+                "score": None,
+                "ai_feedback": "",
+                "teacher_comment": "",
+                "created_at": datetime.now(),
+                "updated_at": datetime.now(),
+            }
+            row = await StudentExperimentRepository(self.db).create(payload)
+            await self._commit()
+            student_exp = self._to_student_experiment_model(row)
 
         user_token_for_url = None
         if self.main._jupyterhub_enabled():
@@ -229,7 +203,7 @@ class SubmissionService:
                         )
                         if exists_resp.status_code == 404:
                             notebook_json = None
-                            template_path = self.main._normalize_text(experiment.notebook_path or "")
+                            template_path = normalize_text(experiment.notebook_path or "")
                             if template_path:
                                 tpl_resp = self.main._user_contents_request(
                                     student_id,
@@ -258,19 +232,14 @@ class SubmissionService:
         return {"student_experiment_id": student_exp.id, "jupyter_url": jupyter_url, "message": "实验环境已启动"}
 
     async def submit_experiment(self, student_exp_id: str, submission):
-        if self.db is None:
-            student_exp = self.main.student_experiments_db.get(student_exp_id)
-            if not student_exp:
-                raise HTTPException(status_code=404, detail="学生实验记录不存在")
-        else:
-            row = await StudentExperimentRepository(self.db).get(student_exp_id)
-            if not row:
-                raise HTTPException(status_code=404, detail="学生实验记录不存在")
-            student_exp = self._to_student_experiment_model(row)
+        row = await StudentExperimentRepository(self.db).get(student_exp_id)
+        if not row:
+            raise HTTPException(status_code=404, detail="学生实验记录不存在")
+        student_exp = self._to_student_experiment_model(row)
 
         try:
             if self.main._jupyterhub_enabled():
-                student_id = self.main._normalize_text(student_exp.student_id)
+                student_id = normalize_text(student_exp.student_id)
                 if not student_id:
                     raise ValueError("student_id missing")
                 if not self.main._ensure_user_server_running(student_id):
@@ -316,32 +285,22 @@ class SubmissionService:
                 file_payload = file_resp.json() or {}
                 notebook_content = file_payload.get("content")
                 if isinstance(notebook_content, dict):
-                    student_exp.notebook_content = json.dumps(notebook_content, ensure_ascii=False)
+                    row.notebook_content = json.dumps(notebook_content, ensure_ascii=False)
                 else:
-                    student_exp.notebook_content = json.dumps(file_payload, ensure_ascii=False)
+                    row.notebook_content = json.dumps(file_payload, ensure_ascii=False)
             elif submission and submission.notebook_content:
-                student_exp.notebook_content = submission.notebook_content
+                row.notebook_content = submission.notebook_content
             else:
-                student_exp.notebook_content = "Error: JupyterHub not configured, and no notebook content provided"
+                row.notebook_content = "Error: JupyterHub not configured, and no notebook content provided"
         except Exception as exc:
-            student_exp.notebook_content = f"Error reading notebook: {exc}"
+            row.notebook_content = f"Error reading notebook: {exc}"
             print(f"Error reading notebook: {exc}")
 
-        student_exp.status = self.main.ExperimentStatus.SUBMITTED
-        student_exp.submit_time = datetime.now()
-
-        if self.db is None:
-            self.main.student_experiments_db[student_exp.id] = student_exp
-        else:
-            row = await StudentExperimentRepository(self.db).get(student_exp.id)
-            row.notebook_content = student_exp.notebook_content or ""
-            row.status = self.main.ExperimentStatus.SUBMITTED.value
-            row.submit_time = student_exp.submit_time
-            row.updated_at = datetime.now()
-            await self._commit()
-            self.main.student_experiments_db[student_exp.id] = student_exp
-
-        return {"message": "实验已提交", "submit_time": student_exp.submit_time}
+        row.status = self.main.ExperimentStatus.SUBMITTED.value
+        row.submit_time = datetime.now()
+        row.updated_at = datetime.now()
+        await self._commit()
+        return {"message": "实验已提交", "submit_time": row.submit_time}
 
     async def upload_submission_pdf(self, student_exp_id: str, file: UploadFile = File(...)):
         if not file.filename:
@@ -350,15 +309,9 @@ class SubmissionService:
         if not is_pdf:
             raise HTTPException(status_code=400, detail="仅支持 PDF 文件")
 
-        if self.db is None:
-            student_exp = self.main.student_experiments_db.get(student_exp_id)
-            if not student_exp:
-                raise HTTPException(status_code=404, detail="学生实验记录不存在")
-        else:
-            row = await StudentExperimentRepository(self.db).get(student_exp_id)
-            if not row:
-                raise HTTPException(status_code=404, detail="学生实验记录不存在")
-            student_exp = self._to_student_experiment_model(row)
+        row = await StudentExperimentRepository(self.db).get(student_exp_id)
+        if not row:
+            raise HTTPException(status_code=404, detail="学生实验记录不存在")
 
         pdf_id = str(uuid.uuid4())
         safe_filename = file.filename.replace(" ", "_")
@@ -374,36 +327,13 @@ class SubmissionService:
                 os.remove(file_path)
             raise HTTPException(status_code=400, detail="PDF文件为空")
 
-        if self.db is None:
-            record = self.main.StudentSubmissionPDF(
-                id=pdf_id,
-                student_exp_id=student_exp_id,
-                experiment_id=student_exp.experiment_id,
-                student_id=student_exp.student_id,
-                filename=file.filename,
-                file_path=file_path,
-                content_type="application/pdf",
-                size=file_size,
-                created_at=datetime.now(),
-            )
-            self.main.submission_pdfs_db[pdf_id] = record
-            return {
-                "id": record.id,
-                "student_exp_id": record.student_exp_id,
-                "filename": record.filename,
-                "size": record.size,
-                "created_at": record.created_at,
-                "review_status": self.main._pdf_status(record),
-                "download_url": f"/api/student-submissions/{record.id}/download",
-            }
-
         now = datetime.now()
-        row = await SubmissionPdfRepository(self.db).create(
+        pdf_row = await SubmissionPdfRepository(self.db).create(
             {
                 "id": pdf_id,
                 "submission_id": student_exp_id,
-                "experiment_id": student_exp.experiment_id,
-                "student_id": student_exp.student_id,
+                "experiment_id": row.experiment_id,
+                "student_id": row.student_id,
                 "filename": file.filename,
                 "file_path": file_path,
                 "content_type": "application/pdf",
@@ -420,40 +350,17 @@ class SubmissionService:
             }
         )
         await self._commit()
-        self.main.submission_pdfs_db[row.id] = self.main.StudentSubmissionPDF(
-            id=row.id,
-            student_exp_id=row.submission_id,
-            experiment_id=row.experiment_id,
-            student_id=row.student_id,
-            filename=row.filename,
-            file_path=row.file_path,
-            content_type=row.content_type,
-            size=row.size,
-            created_at=row.created_at,
-            viewed=row.viewed,
-            viewed_at=row.viewed_at,
-            viewed_by=row.viewed_by or None,
-            reviewed=row.reviewed,
-            reviewed_at=row.reviewed_at,
-            reviewed_by=row.reviewed_by or None,
-            annotations=[],
-        )
         return {
-            "id": row.id,
-            "student_exp_id": row.submission_id,
-            "filename": row.filename,
-            "size": row.size,
-            "created_at": row.created_at,
-            "review_status": self._pdf_status(row),
-            "download_url": f"/api/student-submissions/{row.id}/download",
+            "id": pdf_row.id,
+            "student_exp_id": pdf_row.submission_id,
+            "filename": pdf_row.filename,
+            "size": pdf_row.size,
+            "created_at": pdf_row.created_at,
+            "review_status": self._pdf_status(pdf_row),
+            "download_url": f"/api/student-submissions/{pdf_row.id}/download",
         }
 
     async def list_submission_pdfs(self, student_exp_id: str):
-        if self.db is None:
-            if student_exp_id not in self.main.student_experiments_db:
-                raise HTTPException(status_code=404, detail="学生实验记录不存在")
-            return [self.main._pdf_to_payload(item) for item in self.main._get_submission_pdfs(student_exp_id)]
-
         student_exp = await StudentExperimentRepository(self.db).get(student_exp_id)
         if not student_exp:
             raise HTTPException(status_code=404, detail="学生实验记录不存在")
@@ -461,61 +368,35 @@ class SubmissionService:
         return [self._pdf_to_payload(item) for item in rows]
 
     async def mark_submission_pdf_viewed(self, pdf_id: str, teacher_username: str):
-        self.main._ensure_teacher(teacher_username)
-        if self.db is None:
-            item = self.main.submission_pdfs_db.get(pdf_id)
-            if not item:
-                raise HTTPException(status_code=404, detail="提交 PDF 不存在")
-            item.viewed = True
-            item.viewed_at = datetime.now()
-            item.viewed_by = teacher_username
-            return self.main._pdf_to_payload(item)
-
+        normalized_teacher = await self._ensure_teacher(teacher_username)
         row = await SubmissionPdfRepository(self.db).get(pdf_id)
         if not row:
             raise HTTPException(status_code=404, detail="提交 PDF 不存在")
         row.viewed = True
         row.viewed_at = datetime.now()
-        row.viewed_by = teacher_username
+        row.viewed_by = normalized_teacher
         row.updated_at = datetime.now()
         await self._commit()
         return self._pdf_to_payload(row)
 
     async def add_submission_pdf_annotation(self, pdf_id: str, payload):
-        self.main._ensure_teacher(payload.teacher_username)
-        content = self.main._normalize_text(payload.content)
+        normalized_teacher = await self._ensure_teacher(payload.teacher_username)
+        content = normalize_text(payload.content)
         if not content:
             raise HTTPException(status_code=400, detail="批注内容不能为空")
 
-        if self.db is None:
-            item = self.main.submission_pdfs_db.get(pdf_id)
-            if not item:
-                raise HTTPException(status_code=404, detail="提交 PDF 不存在")
-            if not item.viewed:
-                item.viewed = True
-                item.viewed_at = datetime.now()
-                item.viewed_by = payload.teacher_username
-            annotation = self.main.PDFAnnotation(
-                id=str(uuid.uuid4()),
-                teacher_username=payload.teacher_username,
-                content=content,
-                created_at=datetime.now(),
-            )
-            item.annotations.append(annotation)
-            return self.main._pdf_to_payload(item)
-
         row = await SubmissionPdfRepository(self.db).get(pdf_id)
         if not row:
             raise HTTPException(status_code=404, detail="提交 PDF 不存在")
         if not row.viewed:
             row.viewed = True
             row.viewed_at = datetime.now()
-            row.viewed_by = payload.teacher_username
+            row.viewed_by = normalized_teacher
         annotations = list(row.annotations or [])
         annotations.append(
             {
                 "id": str(uuid.uuid4()),
-                "teacher_username": payload.teacher_username,
+                "teacher_username": normalized_teacher,
                 "content": content,
                 "created_at": datetime.now().isoformat(),
             }
@@ -526,80 +407,44 @@ class SubmissionService:
         return self._pdf_to_payload(row)
 
     async def get_student_experiments(self, student_id: str):
-        if self.db is None:
-            return [exp for exp in self.main.student_experiments_db.values() if exp.student_id == student_id]
         rows = await StudentExperimentRepository(self.db).list_by_student(student_id)
-        items = [self._to_student_experiment_model(row) for row in rows]
-        for item in items:
-            self.main.student_experiments_db[item.id] = item
-        return items
+        return [self._to_student_experiment_model(row) for row in rows]
 
     async def get_student_experiment_detail(self, student_exp_id: str):
-        if self.db is None:
-            item = self.main.student_experiments_db.get(student_exp_id)
-            if not item:
-                raise HTTPException(status_code=404, detail="学生实验记录不存在")
-            return item
         row = await StudentExperimentRepository(self.db).get(student_exp_id)
         if not row:
             raise HTTPException(status_code=404, detail="学生实验记录不存在")
-        item = self._to_student_experiment_model(row)
-        self.main.student_experiments_db[item.id] = item
-        return item
+        return self._to_student_experiment_model(row)
 
     async def get_submission_pdf_row(self, pdf_id: str):
-        if self.db is None:
-            item = self.main.submission_pdfs_db.get(pdf_id)
-            if not item:
-                raise HTTPException(status_code=404, detail="提交 PDF 不存在")
-            return item
         row = await SubmissionPdfRepository(self.db).get(pdf_id)
         if not row:
             raise HTTPException(status_code=404, detail="提交 PDF 不存在")
         return row
 
     async def download_submission_pdf(self, pdf_id: str, teacher_username: Optional[str] = None):
-        if self.db is None:
-            record = self.main.submission_pdfs_db.get(pdf_id)
-            if not record:
-                raise HTTPException(status_code=404, detail="提交 PDF 不存在")
-            if teacher_username and self.main.is_teacher(teacher_username):
-                record.viewed = True
-                record.viewed_at = datetime.now()
-                record.viewed_by = teacher_username
-            return record
-
         row = await SubmissionPdfRepository(self.db).get(pdf_id)
         if not row:
             raise HTTPException(status_code=404, detail="提交 PDF 不存在")
-        if teacher_username and self.main.is_teacher(teacher_username):
-            row.viewed = True
-            row.viewed_at = datetime.now()
-            row.viewed_by = teacher_username
-            row.updated_at = datetime.now()
-            await self._commit()
+        if teacher_username:
+            role = await resolve_user_role(self.db, teacher_username)
+            if role in {"teacher", "admin"}:
+                row.viewed = True
+                row.viewed_at = datetime.now()
+                row.viewed_by = normalize_text(teacher_username)
+                row.updated_at = datetime.now()
+                await self._commit()
         return row
 
     async def get_experiment_submissions(self, experiment_id: str):
-        if self.db is None:
-            submissions = []
-            for exp in self.main.student_experiments_db.values():
-                if exp.experiment_id != experiment_id:
-                    continue
-                if not self.main._is_student_progress_record(exp.student_id):
-                    continue
-                payload = exp.dict()
-                pdf_items = self.main._get_submission_pdfs(exp.id)
-                payload["pdf_attachments"] = [self.main._pdf_to_payload(item) for item in pdf_items]
-                payload["pdf_count"] = len(pdf_items)
-                submissions.append(payload)
-            return submissions
-
         exp_rows = await StudentExperimentRepository(self.db).list_by_experiment(experiment_id)
+        student_rows = await UserRepository(self.db).list_by_role("student")
+        student_ids = {normalize_text(item.student_id or item.username) for item in student_rows}
+
         submissions = []
         pdf_repo = SubmissionPdfRepository(self.db)
         for row in exp_rows:
-            if not self.main._is_student_progress_record(row.student_id):
+            if normalize_text(row.student_id) not in student_ids:
                 continue
             model = self._to_student_experiment_model(row)
             payload = model.dict()
@@ -613,27 +458,11 @@ class SubmissionService:
         if not (0 <= score <= 100):
             raise HTTPException(status_code=400, detail="分数必须在 0-100 之间")
 
-        reviewer = teacher_username if teacher_username and self.main.is_teacher(teacher_username) else "teacher"
-
-        if self.db is None:
-            student_exp = self.main.student_experiments_db.get(student_exp_id)
-            if not student_exp:
-                raise HTTPException(status_code=404, detail="学生实验记录不存在")
-            student_exp.score = score
-            student_exp.teacher_comment = comment
-            student_exp.status = self.main.ExperimentStatus.GRADED
-            now = datetime.now()
-            for item in self.main.submission_pdfs_db.values():
-                if item.student_exp_id != student_exp_id:
-                    continue
-                item.reviewed = True
-                item.reviewed_at = now
-                item.reviewed_by = reviewer
-                if not item.viewed:
-                    item.viewed = True
-                    item.viewed_at = now
-                    item.viewed_by = reviewer
-            return {"message": "评分成功", "score": score}
+        reviewer = "teacher"
+        if teacher_username:
+            role = await resolve_user_role(self.db, teacher_username)
+            if role in {"teacher", "admin"}:
+                reviewer = normalize_text(teacher_username)
 
         student_row = await StudentExperimentRepository(self.db).get(student_exp_id)
         if not student_row:
@@ -655,9 +484,9 @@ class SubmissionService:
                 item.viewed_by = reviewer
             item.updated_at = now
         await self._commit()
-        self.main.student_experiments_db[student_exp_id] = self._to_student_experiment_model(student_row)
         return {"message": "评分成功", "score": score}
 
 
 def build_submission_service(main_module, db: Optional[AsyncSession] = None) -> SubmissionService:
     return SubmissionService(main_module=main_module, db=db)
+
diff --git a/backend/app/services/teacher_service.py b/backend/app/services/teacher_service.py
index 8931422..ecbc22e 100644
--- a/backend/app/services/teacher_service.py
+++ b/backend/app/services/teacher_service.py
@@ -10,6 +10,7 @@ from sqlalchemy.ext.asyncio import AsyncSession
 
 from ..repositories import (
     AttachmentRepository,
+    AuthUserRepository,
     CourseRepository,
     ExperimentRepository,
     PasswordHashRepository,
@@ -17,16 +18,18 @@ from ..repositories import (
     StudentExperimentRepository,
     UserRepository,
 )
+from .identity_service import ensure_teacher_or_admin, normalize_text
+from .operation_log_service import append_operation_log
 
 
 class TeacherService:
     def __init__(self, main_module, db: Optional[AsyncSession] = None):
+        if db is None:
+            raise HTTPException(status_code=503, detail="PostgreSQL session unavailable")
         self.main = main_module
         self.db = db
 
     async def _commit(self):
-        if self.db is None:
-            return
         try:
             await self.db.commit()
         except Exception as exc:
@@ -73,27 +76,41 @@ class TeacherService:
             target_student_ids=list(row.target_student_ids or []),
         )
 
-    def _to_student_experiment(self, row):
-        status_value = row.status or self.main.ExperimentStatus.NOT_STARTED.value
-        try:
-            status_value = self.main.ExperimentStatus(status_value)
-        except ValueError:
-            status_value = self.main.ExperimentStatus.NOT_STARTED
-        return self.main.StudentExperiment(
-            id=row.id,
-            experiment_id=row.experiment_id,
-            student_id=row.student_id,
-            status=status_value,
-            start_time=row.start_time,
-            submit_time=row.submit_time,
-            notebook_content=row.notebook_content or "",
-            score=row.score,
-            ai_feedback=row.ai_feedback or "",
-            teacher_comment=row.teacher_comment or "",
+    def _course_payload(self, course, experiments: list):
+        ordered_experiments = sorted(
+            experiments,
+            key=lambda item: item.created_at or datetime.min,
+            reverse=True,
         )
+        published_count = sum(1 for item in ordered_experiments if item.published)
+        latest_experiment_at = ordered_experiments[0].created_at if ordered_experiments else None
+        tags = sorted({tag for item in ordered_experiments for tag in (item.tags or []) if normalize_text(tag)})
+        return {
+            "id": course.id,
+            "name": course.name,
+            "description": course.description or "",
+            "created_by": course.created_by,
+            "created_at": course.created_at,
+            "updated_at": course.updated_at,
+            "experiment_count": len(ordered_experiments),
+            "published_count": published_count,
+            "latest_experiment_at": latest_experiment_at,
+            "tags": tags,
+            "experiments": ordered_experiments,
+        }
+
+    async def _ensure_teacher(self, username: str) -> tuple[str, str]:
+        return await ensure_teacher_or_admin(self.db, username)
+
+    async def _update_auth_password(self, username: str, new_hash: str):
+        auth_repo = AuthUserRepository(self.db)
+        auth_user = await auth_repo.get_by_login_identifier(username)
+        if auth_user is not None:
+            auth_user.password_hash = new_hash
+            auth_user.updated_at = datetime.now()
 
     async def upsert_teacher_security_question(self, payload):
-        teacher_username = self.main._normalize_text(payload.teacher_username)
+        teacher_username = normalize_text(payload.teacher_username)
         question = self.main._normalize_security_question(payload.security_question or "")
         answer = payload.security_answer or ""
 
@@ -103,75 +120,44 @@ class TeacherService:
             raise HTTPException(status_code=400, detail="密保问题至少 2 个字")
         if len(self.main._normalize_security_answer(answer)) < 2:
             raise HTTPException(status_code=400, detail="密保答案至少 2 个字")
-        self.main._ensure_teacher(teacher_username)
 
-        if self.db is None:
-            self.main.account_security_questions_db[teacher_username] = {
+        normalized_teacher, _ = await self._ensure_teacher(teacher_username)
+        repo = SecurityQuestionRepository(self.db)
+        existing = await repo.get_by_username(normalized_teacher)
+        await repo.upsert(
+            {
+                "id": existing.id if existing else str(uuid.uuid4()),
+                "username": normalized_teacher,
+                "role": "teacher",
                 "question": question,
                 "answer_hash": self.main._hash_security_answer(answer),
+                "created_at": existing.created_at if existing else datetime.now(),
+                "updated_at": datetime.now(),
             }
-            self.main._append_operation_log(
-                operator=teacher_username,
-                action="accounts.update_security_question",
-                target=teacher_username,
-                detail="教师/管理员更新密保问题",
-            )
-            return {"message": "密保问题已保存"}
-
-        repo = SecurityQuestionRepository(self.db)
-        existing = await repo.get_by_username(teacher_username)
-        payload_row = {
-            "id": existing.id if existing else str(uuid.uuid4()),
-            "username": teacher_username,
-            "role": "teacher",
-            "question": question,
-            "answer_hash": self.main._hash_security_answer(answer),
-            "created_at": existing.created_at if existing else datetime.now(),
-            "updated_at": datetime.now(),
-        }
-        await repo.upsert(payload_row)
-        await self._commit()
-        self.main.account_security_questions_db[teacher_username] = {
-            "question": question,
-            "answer_hash": self.main._hash_security_answer(answer),
-        }
-        self.main._append_operation_log(
-            operator=teacher_username,
+        )
+        await append_operation_log(
+            self.db,
+            operator=normalized_teacher,
             action="accounts.update_security_question",
-            target=teacher_username,
+            target=normalized_teacher,
             detail="教师/管理员更新密保问题",
         )
+        await self._commit()
         return {"message": "密保问题已保存"}
 
     async def change_teacher_password(self, payload):
-        teacher_username = self.main._normalize_text(payload.teacher_username)
+        teacher_username = normalize_text(payload.teacher_username)
         old_password = payload.old_password or ""
         new_password = payload.new_password or ""
 
         if not teacher_username or not old_password or not new_password:
             raise HTTPException(status_code=400, detail="账号、旧密码和新密码不能为空")
-        self.main._ensure_teacher(teacher_username)
+        await self._ensure_teacher(teacher_username)
         if len(new_password) < 6:
-            raise HTTPException(status_code=400, detail="新密码长度不能少于 6 位")
+            raise HTTPException(status_code=400, detail="新密码长度不能少于6位")
         if old_password == new_password:
             raise HTTPException(status_code=400, detail="新密码不能与旧密码相同")
 
-        if self.db is None:
-            if not self.main._verify_account_password(teacher_username, old_password):
-                raise HTTPException(status_code=401, detail="旧密码错误")
-            new_hash = self.main._hash_password(new_password)
-            if new_hash == self.main._default_password_hash():
-                self.main.teacher_account_password_hashes_db.pop(teacher_username, None)
-            else:
-                self.main.teacher_account_password_hashes_db[teacher_username] = new_hash
-            self.main._append_operation_log(
-                operator=teacher_username,
-                action="accounts.change_password",
-                target=teacher_username,
-                detail="教师端修改密码",
-            )
-            return {"message": "密码修改成功"}
-
         repo = PasswordHashRepository(self.db)
         current_row = await repo.get_by_username(teacher_username)
         current_hash = current_row.password_hash if current_row else self.main._default_password_hash()
@@ -181,125 +167,89 @@ class TeacherService:
         new_hash = self.main._hash_password(new_password)
         if new_hash == self.main._default_password_hash():
             await repo.delete_by_username(teacher_username)
-            self.main.teacher_account_password_hashes_db.pop(teacher_username, None)
         else:
-            payload_row = {
-                "id": current_row.id if current_row else str(uuid.uuid4()),
-                "username": teacher_username,
-                "role": "teacher",
-                "password_hash": new_hash,
-                "created_at": current_row.created_at if current_row else datetime.now(),
-                "updated_at": datetime.now(),
-            }
-            await repo.upsert(payload_row)
-            self.main.teacher_account_password_hashes_db[teacher_username] = new_hash
+            await repo.upsert(
+                {
+                    "id": current_row.id if current_row else str(uuid.uuid4()),
+                    "username": teacher_username,
+                    "role": "teacher",
+                    "password_hash": new_hash,
+                    "created_at": current_row.created_at if current_row else datetime.now(),
+                    "updated_at": datetime.now(),
+                }
+            )
 
-        await self._commit()
-        self.main._append_operation_log(
+        await self._update_auth_password(teacher_username, new_hash)
+        await append_operation_log(
+            self.db,
             operator=teacher_username,
             action="accounts.change_password",
             target=teacher_username,
             detail="教师端修改密码",
         )
+        await self._commit()
         return {"message": "密码修改成功"}
 
-    def _course_payload(self, course, experiments: list):
-        ordered_experiments = sorted(
-            experiments,
-            key=lambda item: item.created_at or datetime.min,
-            reverse=True,
-        )
-        published_count = sum(1 for item in ordered_experiments if item.published)
-        latest_experiment_at = ordered_experiments[0].created_at if ordered_experiments else None
-        tags = sorted({tag for item in ordered_experiments for tag in (item.tags or []) if self.main._normalize_text(tag)})
-        return {
-            "id": course.id,
-            "name": course.name,
-            "description": course.description or "",
-            "created_by": course.created_by,
-            "created_at": course.created_at,
-            "updated_at": course.updated_at,
-            "experiment_count": len(ordered_experiments),
-            "published_count": published_count,
-            "latest_experiment_at": latest_experiment_at,
-            "tags": tags,
-            "experiments": ordered_experiments,
-        }
-
     async def get_teacher_courses(self, teacher_username: str):
-        normalized_teacher = self.main._normalize_text(teacher_username)
-        self.main._ensure_teacher(normalized_teacher)
-        if self.db is None:
-            course_items = [
-                item
-                for item in self.main.courses_db.values()
-                if self.main._normalize_text(item.created_by) == normalized_teacher
-            ]
-            course_items.sort(key=lambda item: item.updated_at or item.created_at or datetime.min, reverse=True)
-            return [self.main._course_to_payload(item) for item in course_items]
-
+        normalized_teacher, _ = await self._ensure_teacher(teacher_username)
         course_rows = await CourseRepository(self.db).list_by_creator(normalized_teacher)
         experiment_rows = await ExperimentRepository(self.db).list_all()
         experiments = [self._to_experiment_model(item) for item in experiment_rows]
-        for exp in experiments:
-            self.main.experiments_db[exp.id] = exp
 
         payload = []
         for row in course_rows:
             course = self._to_course_record(row)
-            self.main.courses_db[course.id] = course
             owned = [
                 item
                 for item in experiments
-                if self.main._normalize_text(item.created_by) == normalized_teacher
-                and self.main._normalize_text(item.course_id) == self.main._normalize_text(course.id)
+                if normalize_text(item.created_by) == normalized_teacher
+                and normalize_text(item.course_id) == normalize_text(course.id)
             ]
             payload.append(self._course_payload(course, owned))
         payload.sort(key=lambda item: item.get("updated_at") or item.get("created_at") or datetime.min, reverse=True)
         return payload
 
     async def get_teacher_publish_targets(self, teacher_username: str):
-        normalized_teacher = self.main._normalize_text(teacher_username)
-        self.main._ensure_teacher(normalized_teacher)
-
-        if self.db is None:
-            classes = sorted(self.main._list_accessible_classes(normalized_teacher), key=lambda item: item.name)
-            students = [item for item in self.main.students_db.values() if self.main._student_visible_to_teacher(item, normalized_teacher)]
-            students.sort(key=lambda item: (item.class_name, item.student_id))
-        else:
-            user_repo = UserRepository(self.db)
-            class_rows = await user_repo.list_classes()
-            student_rows = await user_repo.list_by_role("student")
-
-            classes = []
-            for row in class_rows:
-                if self.main._is_admin_user(normalized_teacher) or self.main._normalize_text(row.created_by) == normalized_teacher:
-                    classes.append(self.main.ClassRecord(id=row.id, name=row.name, created_by=row.created_by, created_at=row.created_at))
-            classes.sort(key=lambda item: item.name)
-            class_names = {item.name for item in classes}
-
-            students = []
-            for row in student_rows:
-                student = self.main.StudentRecord(
-                    student_id=row.student_id or row.username,
-                    username=row.username,
-                    real_name=row.real_name or row.username,
-                    class_name=row.class_name or "",
-                    admission_year=row.admission_year or "",
-                    organization=row.organization or "",
-                    phone=row.phone or "",
-                    role="student",
-                    created_by=row.created_by or "",
-                    password_hash=row.password_hash or "",
-                    security_question=row.security_question or "",
-                    security_answer_hash=row.security_answer_hash or "",
-                    created_at=row.created_at,
-                    updated_at=row.updated_at,
-                )
-                if self.main._is_admin_user(normalized_teacher) or student.class_name in class_names:
-                    students.append(student)
-                    self.main.students_db[student.student_id] = student
-            students.sort(key=lambda item: (item.class_name, item.student_id))
+        normalized_teacher, role = await self._ensure_teacher(teacher_username)
+        user_repo = UserRepository(self.db)
+        class_rows = await user_repo.list_classes()
+        student_rows = await user_repo.list_by_role("student")
+
+        classes = []
+        for row in class_rows:
+            if role == "admin" or normalize_text(row.created_by) == normalized_teacher:
+                classes.append(self.main.ClassRecord(id=row.id, name=row.name, created_by=row.created_by, created_at=row.created_at))
+        classes.sort(key=lambda item: item.name)
+
+        class_owner_map = {}
+        for item in classes:
+            class_owner_map[item.name] = normalize_text(item.created_by)
+
+        students = []
+        for row in student_rows:
+            student = self.main.StudentRecord(
+                student_id=row.student_id or row.username,
+                username=row.username,
+                real_name=row.real_name or row.username,
+                class_name=row.class_name or "",
+                admission_year=row.admission_year or "",
+                organization=row.organization or "",
+                phone=row.phone or "",
+                role="student",
+                created_by=row.created_by or "",
+                password_hash=row.password_hash or "",
+                security_question=row.security_question or "",
+                security_answer_hash=row.security_answer_hash or "",
+                created_at=row.created_at,
+                updated_at=row.updated_at,
+            )
+            if role == "admin":
+                students.append(student)
+                continue
+            owner = normalize_text(student.created_by) or class_owner_map.get(student.class_name, "")
+            if owner == normalized_teacher:
+                students.append(student)
+        students.sort(key=lambda item: (item.class_name, item.student_id))
 
         return {
             "classes": [{"id": item.id, "name": item.name} for item in classes],
@@ -310,18 +260,11 @@ class TeacherService:
         }
 
     async def create_teacher_course(self, payload):
-        normalized_teacher = self.main._normalize_text(payload.teacher_username)
-        self.main._ensure_teacher(normalized_teacher)
-        course_name = self.main._normalize_text(payload.name)
+        normalized_teacher, _ = await self._ensure_teacher(payload.teacher_username)
+        course_name = normalize_text(payload.name)
         if not course_name:
             raise HTTPException(status_code=400, detail="课程名称不能为空")
 
-        if self.db is None:
-            if self.main._find_teacher_course_by_name(normalized_teacher, course_name):
-                raise HTTPException(status_code=409, detail="课程名称已存在")
-            course = self.main._create_course_record(course_name, normalized_teacher, payload.description or "")
-            return self.main._course_to_payload(course)
-
         repo = CourseRepository(self.db)
         if await repo.find_by_teacher_and_name(normalized_teacher, course_name):
             raise HTTPException(status_code=409, detail="课程名称已存在")
@@ -331,35 +274,33 @@ class TeacherService:
             {
                 "id": str(uuid.uuid4()),
                 "name": course_name,
-                "description": self.main._normalize_text(payload.description or ""),
+                "description": normalize_text(payload.description or ""),
                 "created_by": normalized_teacher,
                 "created_at": now,
                 "updated_at": now,
             }
         )
+        await append_operation_log(
+            self.db,
+            operator=normalized_teacher,
+            action="courses.create",
+            target=course_name,
+            detail=f"course_id={row.id}",
+        )
         await self._commit()
         course = self._to_course_record(row)
-        self.main.courses_db[course.id] = course
         return self._course_payload(course, [])
 
     async def update_teacher_course(self, course_id: str, payload):
-        normalized_teacher = self.main._normalize_text(payload.teacher_username)
-        self.main._ensure_teacher(normalized_teacher)
-
-        if self.db is None:
-            course = self.main.courses_db.get(course_id)
-            if not course or self.main._normalize_text(course.created_by) != normalized_teacher:
-                raise HTTPException(status_code=404, detail="课程不存在")
-            return self.main._course_to_payload(course)
-
+        normalized_teacher, _ = await self._ensure_teacher(payload.teacher_username)
         course_repo = CourseRepository(self.db)
         exp_repo = ExperimentRepository(self.db)
         row = await course_repo.get(course_id)
-        if not row or self.main._normalize_text(row.created_by) != normalized_teacher:
+        if not row or normalize_text(row.created_by) != normalized_teacher:
             raise HTTPException(status_code=404, detail="课程不存在")
 
-        next_name = self.main._normalize_text(payload.name) or row.name
-        if self.main._normalize_text(next_name).lower() != self.main._normalize_text(row.name).lower():
+        next_name = normalize_text(payload.name) or row.name
+        if normalize_text(next_name).lower() != normalize_text(row.name).lower():
             existing = await course_repo.find_by_teacher_and_name(normalized_teacher, next_name)
             if existing and existing.id != row.id:
                 raise HTTPException(status_code=409, detail="课程名称已存在")
@@ -368,45 +309,41 @@ class TeacherService:
 
             experiment_rows = await exp_repo.list_by_course_ids([course_id])
             for item in experiment_rows:
-                if self.main._normalize_text(item.created_by) != normalized_teacher:
+                if normalize_text(item.created_by) != normalized_teacher:
                     continue
-                if self.main._normalize_text(item.course_name) == self.main._normalize_text(old_name):
+                if normalize_text(item.course_name) == normalize_text(old_name):
                     item.course_name = next_name
 
         if payload.description is not None:
-            row.description = self.main._normalize_text(payload.description)
+            row.description = normalize_text(payload.description)
         row.updated_at = datetime.now()
-        await self._commit()
 
-        course = self._to_course_record(row)
-        self.main.courses_db[course.id] = course
         related_rows = await exp_repo.list_by_course_ids([course_id])
-        related = [self._to_experiment_model(item) for item in related_rows if self.main._normalize_text(item.created_by) == normalized_teacher]
-        for item in related:
-            self.main.experiments_db[item.id] = item
-        return self._course_payload(course, related)
+        related = [self._to_experiment_model(item) for item in related_rows if normalize_text(item.created_by) == normalized_teacher]
+        await append_operation_log(
+            self.db,
+            operator=normalized_teacher,
+            action="courses.update",
+            target=course_id,
+            detail=f"name={row.name}",
+        )
+        await self._commit()
+        return self._course_payload(self._to_course_record(row), related)
 
     async def delete_teacher_course(self, course_id: str, teacher_username: str, delete_experiments: bool = False):
-        normalized_teacher = self.main._normalize_text(teacher_username)
-        self.main._ensure_teacher(normalized_teacher)
-
-        if self.db is None:
-            course = self.main.courses_db.get(course_id)
-            if not course or self.main._normalize_text(course.created_by) != normalized_teacher:
-                raise HTTPException(status_code=404, detail="课程不存在")
-            return {"message": "课程已删除", "id": course_id}
+        normalized_teacher, _ = await self._ensure_teacher(teacher_username)
 
         course_repo = CourseRepository(self.db)
         exp_repo = ExperimentRepository(self.db)
         att_repo = AttachmentRepository(self.db)
         course_row = await course_repo.get(course_id)
-        if not course_row or self.main._normalize_text(course_row.created_by) != normalized_teacher:
+        if not course_row or normalize_text(course_row.created_by) != normalized_teacher:
             raise HTTPException(status_code=404, detail="课程不存在")
 
         exp_rows = [
             item
             for item in await exp_repo.list_by_course_ids([course_id])
-            if self.main._normalize_text(item.created_by) == normalized_teacher
+            if normalize_text(item.created_by) == normalized_teacher
         ]
         if exp_rows and not delete_experiments:
             raise HTTPException(status_code=409, detail="课程下存在实验，请先删除实验或传入 delete_experiments=true")
@@ -422,42 +359,44 @@ class TeacherService:
                             pass
                     await att_repo.delete(att.id)
                 await exp_repo.delete(exp.id)
-                self.main.experiments_db.pop(exp.id, None)
 
         await course_repo.delete(course_id)
+        await append_operation_log(
+            self.db,
+            operator=normalized_teacher,
+            action="courses.delete",
+            target=course_id,
+            detail=f"delete_experiments={bool(delete_experiments)}",
+        )
         await self._commit()
-        self.main.courses_db.pop(course_id, None)
         return {"message": "课程已删除", "id": course_id}
 
     async def toggle_course_publish(self, course_id: str, teacher_username: str, published: bool):
-        normalized_teacher = self.main._normalize_text(teacher_username)
-        self.main._ensure_teacher(normalized_teacher)
-
-        if self.db is None:
-            course = self.main.courses_db.get(course_id)
-            if not course or self.main._normalize_text(course.created_by) != normalized_teacher:
-                raise HTTPException(status_code=404, detail="课程不存在")
-            return {"message": "课程下暂无实验", "published": published, "updated": 0}
-
+        normalized_teacher, _ = await self._ensure_teacher(teacher_username)
         course_repo = CourseRepository(self.db)
         exp_repo = ExperimentRepository(self.db)
         course = await course_repo.get(course_id)
-        if not course or self.main._normalize_text(course.created_by) != normalized_teacher:
+        if not course or normalize_text(course.created_by) != normalized_teacher:
             raise HTTPException(status_code=404, detail="课程不存在")
 
         related = [
             item
             for item in await exp_repo.list_by_course_ids([course_id])
-            if self.main._normalize_text(item.created_by) == normalized_teacher
+            if normalize_text(item.created_by) == normalized_teacher
         ]
         if not related:
             return {"message": "课程下暂无实验", "published": published, "updated": 0}
 
         for item in related:
             item.published = published
-            self.main.experiments_db[item.id] = self._to_experiment_model(item)
         course.updated_at = datetime.now()
-        self.main.courses_db[course.id] = self._to_course_record(course)
+        await append_operation_log(
+            self.db,
+            operator=normalized_teacher,
+            action="courses.toggle_publish",
+            target=course_id,
+            detail=f"published={bool(published)}",
+        )
         await self._commit()
         return {
             "message": f"Course publish state updated: {'published' if published else 'unpublished'}",
@@ -466,37 +405,24 @@ class TeacherService:
         }
 
     async def get_all_student_progress(self, teacher_username: str):
-        normalized_teacher = self.main._normalize_text(teacher_username)
-        self.main._ensure_teacher(normalized_teacher)
-
-        if self.db is None:
-            owned_course_ids = {item.id for item in self.main.experiments_db.values() if self.main._normalize_text(item.created_by) == normalized_teacher}
-            progress = [
-                {
-                    "student_id": exp.student_id,
-                    "experiment_id": exp.experiment_id,
-                    "status": exp.status.value,
-                    "start_time": exp.start_time,
-                    "submit_time": exp.submit_time,
-                    "score": exp.score,
-                }
-                for exp in self.main.student_experiments_db.values()
-                if exp.experiment_id in owned_course_ids and self.main._is_student_progress_record(exp.student_id)
-            ]
-            return progress
+        normalized_teacher, _ = await self._ensure_teacher(teacher_username)
 
         exp_rows = await ExperimentRepository(self.db).list_all()
         owned_experiment_ids = {
             item.id
             for item in exp_rows
-            if self.main._normalize_text(item.created_by) == normalized_teacher
+            if normalize_text(item.created_by) == normalized_teacher
         }
+
+        student_rows = await UserRepository(self.db).list_by_role("student")
+        student_ids = {normalize_text(item.student_id or item.username) for item in student_rows}
+
         submissions = await StudentExperimentRepository(self.db).list_all()
         payload = []
         for row in submissions:
             if row.experiment_id not in owned_experiment_ids:
                 continue
-            if not self.main._is_student_progress_record(row.student_id):
+            if normalize_text(row.student_id) not in student_ids:
                 continue
             status_value = row.status or self.main.ExperimentStatus.NOT_STARTED.value
             payload.append(
@@ -512,18 +438,6 @@ class TeacherService:
         return payload
 
     async def get_statistics(self):
-        if self.db is None:
-            total_experiments = len(self.main.experiments_db)
-            total_submissions = len(self.main.student_experiments_db)
-            status_count = {}
-            for exp in self.main.student_experiments_db.values():
-                status_count[exp.status.value] = status_count.get(exp.status.value, 0) + 1
-            return {
-                "total_experiments": total_experiments,
-                "total_submissions": total_submissions,
-                "status_distribution": status_count,
-            }
-
         experiments = await ExperimentRepository(self.db).list_all()
         submissions = await StudentExperimentRepository(self.db).list_all()
         status_count = {}
diff --git a/backend/app/storage_config.py b/backend/app/storage_config.py
index d066772..7c1524f 100644
--- a/backend/app/storage_config.py
+++ b/backend/app/storage_config.py
@@ -1,8 +1,5 @@
 import os
 import re
-from typing import Literal
-
-StorageBackend = Literal["postgres"]
 
 _SCHEMA_PATTERN = re.compile(r"^[A-Za-z_][A-Za-z0-9_]*$")
 _FALSE_VALUES = {"0", "false", "no", "off", ""}
@@ -28,15 +25,6 @@ def _build_database_url() -> str:
     return f"postgresql://{auth}@{host}:{port}/{dbname}"
 
 
-def _normalize_backend(value: str) -> StorageBackend:
-    normalized = str(value or "").strip().lower()
-    if normalized and normalized != "postgres":
-        raise RuntimeError(
-            f"Unsupported STORAGE_BACKEND={value!r}. Only 'postgres' is allowed; json/hybrid modes are removed."
-        )
-    return "postgres"
-
-
 def _normalize_schema(value: str) -> str:
     schema = str(value or "experiment_manager").strip() or "experiment_manager"
     if not _SCHEMA_PATTERN.fullmatch(schema):
@@ -47,6 +35,11 @@ def _normalize_schema(value: str) -> str:
 
 
 def _enforce_removed_legacy_switches() -> None:
+    configured_backend = str(os.getenv("STORAGE_BACKEND") or "").strip().lower()
+    if configured_backend and configured_backend != "postgres":
+        raise RuntimeError(
+            f"Unsupported STORAGE_BACKEND={configured_backend!r}. Runtime storage is fixed to PostgreSQL."
+        )
     if _is_enabled(os.getenv("AUTO_IMPORT_JSON_TO_PG")):
         raise RuntimeError("AUTO_IMPORT_JSON_TO_PG is removed. Use offline migrate_json_to_pg script instead.")
     if _is_enabled(os.getenv("DOUBLE_WRITE_JSON")):
@@ -54,7 +47,7 @@ def _enforce_removed_legacy_switches() -> None:
 
 
 _enforce_removed_legacy_switches()
-STORAGE_BACKEND: StorageBackend = _normalize_backend(os.getenv("STORAGE_BACKEND", "postgres"))
+STORAGE_BACKEND: str = "postgres"
 DATABASE_URL: str = _build_database_url()
 POSTGRES_SCHEMA: str = _normalize_schema(os.getenv("POSTGRES_SCHEMA", "experiment_manager"))
 
diff --git a/docker-compose.server.yml b/docker-compose.server.yml
index 02d63fc..ef2fd1c 100644
--- a/docker-compose.server.yml
+++ b/docker-compose.server.yml
@@ -69,7 +69,6 @@ services:
       - training-uploads:/app/uploads
     environment:
       DATABASE_URL: postgresql://jupyterhub:${DB_PASSWORD:-changeme}@postgres/jupyterhub
-      STORAGE_BACKEND: postgres
       POSTGRES_SCHEMA: ${POSTGRES_SCHEMA:-experiment_manager}
       REDIS_URL: redis://redis:6379/0
       TAVILY_API_KEY: ${TAVILY_API_KEY:-}
diff --git a/docker-compose.yml b/docker-compose.yml
index 302803d..2d46ef9 100644
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -74,7 +74,6 @@ services:
       - training-uploads:/app/uploads
     environment:
       DATABASE_URL: postgresql://jupyterhub:${DB_PASSWORD:-changeme}@postgres/jupyterhub
-      STORAGE_BACKEND: postgres
       POSTGRES_SCHEMA: ${POSTGRES_SCHEMA:-experiment_manager}
       REDIS_URL: redis://redis:6379/0
       TAVILY_API_KEY: ${TAVILY_API_KEY:-}
@@ -102,8 +101,6 @@ services:
       - /var/run/docker.sock:/var/run/docker.sock
       # JupyterHub 数据持久化
       - jupyterhub-data:/srv/jupyterhub
-      # Shared uploads volume for dynamic resource policy
-      - training-uploads:/srv/jupyterhub/shared-uploads
       # 挂载配置文件（开发模式推荐）
       - ./jupyterhub/jupyterhub_config.py:/srv/jupyterhub/jupyterhub_config.py
     environment:
@@ -117,7 +114,6 @@ services:
       # Backend service token (for Hub API calls)
       EXPERIMENT_MANAGER_API_TOKEN: ${EXPERIMENT_MANAGER_API_TOKEN:-training-jhub-service-token}
       JUPYTERHUB_BASE_URL: ${JUPYTERHUB_BASE_URL:-/jupyter}
-      RESOURCE_POLICY_FILE: /srv/jupyterhub/shared-uploads/user_resource_policy.json
       ADMIN_ACCOUNTS: ${ADMIN_ACCOUNTS:-admin}
       TEACHER_ACCOUNTS: ${TEACHER_ACCOUNTS:-teacher_001,teacher_002,teacher_003,teacher_004,teacher_005}
     networks:
diff --git a/jupyterhub/jupyterhub_config.py b/jupyterhub/jupyterhub_config.py
index e01baad..b770ecc 100644
--- a/jupyterhub/jupyterhub_config.py
+++ b/jupyterhub/jupyterhub_config.py
@@ -1,7 +1,8 @@
-import json
 import os
 import re
 
+import psycopg2
+
 
 def _parse_accounts(raw: str, fallback: str) -> list:
     source = raw if raw is not None else fallback
@@ -85,7 +86,10 @@ def _resolve_compose_project_name(resolved_network_name: str) -> str:
 
 compose_project_name = _resolve_compose_project_name(network_name)
 notebook_image = os.environ.get("DOCKER_NOTEBOOK_IMAGE", "training-lab:latest")
-resource_policy_file = os.environ.get("RESOURCE_POLICY_FILE", "/srv/jupyterhub/user_resource_policy.json")
+experiment_manager_db_url = os.environ.get("EXPERIMENT_MANAGER_DATABASE_URL", os.environ.get("HUB_DB_URL", ""))
+experiment_manager_schema = str(os.environ.get("POSTGRES_SCHEMA", "experiment_manager") or "experiment_manager").strip()
+if not re.match(r"^[A-Za-z_][A-Za-z0-9_]*$", experiment_manager_schema):
+    experiment_manager_schema = "experiment_manager"
 teacher_accounts = set(
     _parse_accounts(
         os.environ.get("TEACHER_ACCOUNTS"),
@@ -191,16 +195,22 @@ def _infer_role(username: str) -> str:
 
 def _load_resource_policy():
     payload = {"defaults": dict(default_role_limits), "overrides": {}}
-    if not os.path.exists(resource_policy_file):
+    if not experiment_manager_db_url:
         return payload
 
     try:
-        with open(resource_policy_file, "r", encoding="utf-8") as file_obj:
-            data = json.load(file_obj) or {}
-        if isinstance(data, dict):
-            payload.update(data)
+        with psycopg2.connect(experiment_manager_db_url) as conn:
+            with conn.cursor() as cursor:
+                cursor.execute(
+                    f'SELECT value_json FROM \"{experiment_manager_schema}\".\"app_kv_store\" WHERE key = %s',
+                    ("resource_policy",),
+                )
+                row = cursor.fetchone()
+                data = row[0] if row else {}
+                if isinstance(data, dict):
+                    payload.update(data)
     except Exception as exc:
-        print(f"[resource-policy] failed to load policy: {exc}")
+        print(f"[resource-policy] failed to load policy from postgres: {exc}")
     return payload
 
 
diff --git a/backend/app/repositories/kv_store.py b/backend/app/repositories/kv_store.py
new file mode 100644
index 0000000..04d5769
--- /dev/null
+++ b/backend/app/repositories/kv_store.py
@@ -0,0 +1,34 @@
+from typing import Any
+
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from ..db.models import AppKVStoreORM
+
+
+class KVStoreRepository:
+    def __init__(self, db: AsyncSession):
+        self.db = db
+
+    async def get(self, key: str) -> AppKVStoreORM | None:
+        if not key:
+            return None
+        return await self.db.get(AppKVStoreORM, key)
+
+    async def upsert(self, key: str, value_json: dict[str, Any]) -> AppKVStoreORM:
+        if not key:
+            raise ValueError("kv key is required")
+
+        record = await self.get(key)
+        if record is None:
+            record = AppKVStoreORM(key=key, value_json=value_json or {})
+            self.db.add(record)
+            return record
+
+        record.value_json = value_json or {}
+        return record
+
+    async def list_all(self) -> list[AppKVStoreORM]:
+        result = await self.db.execute(select(AppKVStoreORM))
+        return list(result.scalars().all())
+
diff --git a/backend/app/repositories/operation_logs.py b/backend/app/repositories/operation_logs.py
new file mode 100644
index 0000000..be3eb7d
--- /dev/null
+++ b/backend/app/repositories/operation_logs.py
@@ -0,0 +1,73 @@
+from collections.abc import Sequence
+from datetime import datetime
+from typing import Any
+
+from sqlalchemy import delete, desc, func, select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from ..db.models import OperationLogORM
+
+
+class OperationLogRepository:
+    def __init__(self, db: AsyncSession):
+        self.db = db
+
+    async def create(self, payload: dict[str, Any]) -> OperationLogORM:
+        record = OperationLogORM(**payload)
+        self.db.add(record)
+        return record
+
+    async def get(self, log_id: str) -> OperationLogORM | None:
+        if not log_id:
+            return None
+        return await self.db.get(OperationLogORM, log_id)
+
+    async def list_recent(self, limit: int = 200) -> Sequence[OperationLogORM]:
+        safe_limit = max(1, min(int(limit or 200), 1000))
+        stmt = select(OperationLogORM).order_by(desc(OperationLogORM.created_at)).limit(safe_limit)
+        result = await self.db.execute(stmt)
+        return list(result.scalars().all())
+
+    async def list_all(self) -> Sequence[OperationLogORM]:
+        result = await self.db.execute(select(OperationLogORM).order_by(desc(OperationLogORM.created_at)))
+        return list(result.scalars().all())
+
+    async def count(self) -> int:
+        stmt = select(func.count()).select_from(OperationLogORM)
+        value = await self.db.scalar(stmt)
+        return int(value or 0)
+
+    async def delete_except_recent(self, keep_recent: int) -> int:
+        safe_keep = max(0, min(int(keep_recent or 0), 1000))
+        rows = await self.list_all()
+        if safe_keep == 0:
+            target_ids = [item.id for item in rows]
+        else:
+            target_ids = [item.id for item in rows[safe_keep:]]
+
+        if not target_ids:
+            return 0
+        await self.db.execute(delete(OperationLogORM).where(OperationLogORM.id.in_(target_ids)))
+        return len(target_ids)
+
+    async def append(
+        self,
+        *,
+        log_id: str,
+        operator: str,
+        action: str,
+        target: str,
+        detail: str = "",
+        success: bool = True,
+        created_at: datetime | None = None,
+    ) -> OperationLogORM:
+        payload = {
+            "id": log_id,
+            "operator": operator,
+            "action": action,
+            "target": target,
+            "detail": detail,
+            "success": bool(success),
+            "created_at": created_at or datetime.now(),
+        }
+        return await self.create(payload)
diff --git a/backend/app/repositories/resources.py b/backend/app/repositories/resources.py
new file mode 100644
index 0000000..1d8daf9
--- /dev/null
+++ b/backend/app/repositories/resources.py
@@ -0,0 +1,48 @@
+from collections.abc import Sequence
+from typing import Any
+
+from sqlalchemy import select
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from ..db.models import ResourceORM
+
+
+class ResourceRepository:
+    def __init__(self, db: AsyncSession):
+        self.db = db
+
+    async def create(self, payload: dict[str, Any]) -> ResourceORM:
+        record = ResourceORM(**payload)
+        self.db.add(record)
+        return record
+
+    async def get(self, resource_id: str) -> ResourceORM | None:
+        if not resource_id:
+            return None
+        return await self.db.get(ResourceORM, resource_id)
+
+    async def list_all(self) -> Sequence[ResourceORM]:
+        result = await self.db.execute(select(ResourceORM))
+        return list(result.scalars().all())
+
+    async def update(self, record: ResourceORM, payload: dict[str, Any]) -> ResourceORM:
+        for key, value in payload.items():
+            setattr(record, key, value)
+        return record
+
+    async def upsert(self, payload: dict[str, Any]) -> ResourceORM:
+        resource_id = str(payload.get("id") or "").strip()
+        if not resource_id:
+            raise ValueError("resource id is required")
+        record = await self.get(resource_id)
+        if record is None:
+            return await self.create(payload)
+        return await self.update(record, payload)
+
+    async def delete(self, resource_id: str) -> ResourceORM | None:
+        record = await self.get(resource_id)
+        if record is None:
+            return None
+        await self.db.delete(record)
+        return record
+
diff --git a/backend/app/scripts/postgres_self_check.py b/backend/app/scripts/postgres_self_check.py
new file mode 100644
index 0000000..b3a38e1
--- /dev/null
+++ b/backend/app/scripts/postgres_self_check.py
@@ -0,0 +1,308 @@
+import asyncio
+import json
+import uuid
+from datetime import datetime
+
+from ..db.session import close_db_engine, get_db, init_db_engine, init_db_schema
+from ..repositories import (
+    AttachmentRepository,
+    AuthUserRepository,
+    CourseRepository,
+    ExperimentRepository,
+    KVStoreRepository,
+    OperationLogRepository,
+    ResourceRepository,
+    StudentExperimentRepository,
+    SubmissionPdfRepository,
+    UserRepository,
+)
+
+
+async def _run() -> int:
+    ok = await init_db_engine(force=True)
+    if not ok:
+        print("self-check: PostgreSQL init failed")
+        return 2
+    await init_db_schema()
+
+    token = str(uuid.uuid4())[:8]
+    now = datetime.now()
+    ids = {
+        "class": f"selfcheck-class-{token}",
+        "teacher": f"selfcheck-teacher-{token}",
+        "student": f"selfcheck-student-{token}",
+        "course": f"selfcheck-course-{token}",
+        "experiment": f"selfcheck-exp-{token}",
+        "submission": f"selfcheck-sub-{token}",
+        "pdf": f"selfcheck-pdf-{token}",
+        "resource": f"selfcheck-res-{token}",
+        "attachment": f"selfcheck-att-{token}",
+        "kv": f"selfcheck-kv-{token}",
+        "log": f"selfcheck-log-{token}",
+    }
+
+    async for db in get_db():
+        user_repo = UserRepository(db)
+        auth_repo = AuthUserRepository(db)
+        course_repo = CourseRepository(db)
+        exp_repo = ExperimentRepository(db)
+        sub_repo = StudentExperimentRepository(db)
+        pdf_repo = SubmissionPdfRepository(db)
+        resource_repo = ResourceRepository(db)
+        attachment_repo = AttachmentRepository(db)
+        kv_repo = KVStoreRepository(db)
+        log_repo = OperationLogRepository(db)
+
+        try:
+            await user_repo.upsert_class(
+                {"id": ids["class"], "name": f"SelfCheckClass-{token}", "created_by": ids["teacher"], "created_at": now}
+            )
+            await user_repo.upsert(
+                {
+                    "id": ids["teacher"],
+                    "username": ids["teacher"],
+                    "role": "teacher",
+                    "real_name": "Self Check Teacher",
+                    "student_id": None,
+                    "class_name": "",
+                    "admission_year": "",
+                    "organization": "",
+                    "phone": "",
+                    "password_hash": "",
+                    "security_question": "",
+                    "security_answer_hash": "",
+                    "created_by": "self-check",
+                    "is_active": True,
+                    "created_at": now,
+                    "updated_at": now,
+                    "extra": {},
+                }
+            )
+            await user_repo.upsert(
+                {
+                    "id": ids["student"],
+                    "username": ids["student"],
+                    "role": "student",
+                    "real_name": "Self Check Student",
+                    "student_id": ids["student"],
+                    "class_name": f"SelfCheckClass-{token}",
+                    "admission_year": "2026",
+                    "organization": "SE",
+                    "phone": "000",
+                    "password_hash": "x",
+                    "security_question": "",
+                    "security_answer_hash": "",
+                    "created_by": ids["teacher"],
+                    "is_active": True,
+                    "created_at": now,
+                    "updated_at": now,
+                    "extra": {},
+                }
+            )
+            await auth_repo.upsert_by_email(
+                {
+                    "id": str(uuid.uuid4()),
+                    "email": ids["teacher"],
+                    "username": ids["teacher"],
+                    "role": "teacher",
+                    "password_hash": "x",
+                    "is_active": True,
+                    "created_at": now,
+                    "updated_at": now,
+                }
+            )
+            await auth_repo.upsert_by_email(
+                {
+                    "id": str(uuid.uuid4()),
+                    "email": ids["student"],
+                    "username": ids["student"],
+                    "role": "student",
+                    "password_hash": "x",
+                    "is_active": True,
+                    "created_at": now,
+                    "updated_at": now,
+                }
+            )
+
+            await course_repo.upsert(
+                {
+                    "id": ids["course"],
+                    "name": f"SelfCheckCourse-{token}",
+                    "description": "self check",
+                    "created_by": ids["teacher"],
+                    "created_at": now,
+                    "updated_at": now,
+                }
+            )
+            await exp_repo.upsert(
+                {
+                    "id": ids["experiment"],
+                    "course_id": ids["course"],
+                    "course_name": f"SelfCheckCourse-{token}",
+                    "title": "SelfCheck Experiment",
+                    "description": "",
+                    "difficulty": "beginner",
+                    "tags": ["selfcheck"],
+                    "notebook_path": "",
+                    "resources": {"cpu": 1},
+                    "deadline": None,
+                    "created_by": ids["teacher"],
+                    "published": True,
+                    "publish_scope": "all",
+                    "target_class_names": [],
+                    "target_student_ids": [],
+                    "created_at": now,
+                    "updated_at": now,
+                    "extra": {},
+                }
+            )
+            await sub_repo.upsert(
+                {
+                    "id": ids["submission"],
+                    "experiment_id": ids["experiment"],
+                    "student_id": ids["student"],
+                    "status": "submitted",
+                    "start_time": now,
+                    "submit_time": now,
+                    "notebook_content": "{}",
+                    "score": 90.0,
+                    "ai_feedback": "",
+                    "teacher_comment": "",
+                    "created_at": now,
+                    "updated_at": now,
+                    "extra": {},
+                }
+            )
+            await pdf_repo.upsert(
+                {
+                    "id": ids["pdf"],
+                    "submission_id": ids["submission"],
+                    "experiment_id": ids["experiment"],
+                    "student_id": ids["student"],
+                    "filename": "selfcheck.pdf",
+                    "file_path": "/tmp/selfcheck.pdf",
+                    "content_type": "application/pdf",
+                    "size": 1,
+                    "viewed": False,
+                    "viewed_at": None,
+                    "viewed_by": "",
+                    "reviewed": False,
+                    "reviewed_at": None,
+                    "reviewed_by": "",
+                    "annotations": [],
+                    "created_at": now,
+                    "updated_at": now,
+                }
+            )
+            await resource_repo.upsert(
+                {
+                    "id": ids["resource"],
+                    "filename": "selfcheck.txt",
+                    "file_path": "/tmp/selfcheck.txt",
+                    "file_type": "txt",
+                    "content_type": "text/plain",
+                    "size": 1,
+                    "created_by": ids["teacher"],
+                    "created_at": now,
+                    "updated_at": now,
+                }
+            )
+            await attachment_repo.upsert(
+                {
+                    "id": ids["attachment"],
+                    "experiment_id": ids["experiment"],
+                    "filename": "selfcheck.docx",
+                    "file_path": "/tmp/selfcheck.docx",
+                    "content_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
+                    "size": 1,
+                    "created_at": now,
+                    "updated_at": now,
+                }
+            )
+            await kv_repo.upsert(ids["kv"], {"ok": True, "token": token})
+            await log_repo.append(
+                log_id=ids["log"],
+                operator="self-check",
+                action="self_check.run",
+                target=token,
+                detail="postgres crud check",
+                success=True,
+                created_at=now,
+            )
+            await db.commit()
+
+            checks = {
+                "class": bool(await user_repo.get_class_by_name(f"SelfCheckClass-{token}")),
+                "teacher": bool(await user_repo.get_by_username(ids["teacher"])),
+                "student": bool(await user_repo.get_student_by_student_id(ids["student"])),
+                "course": bool(await course_repo.get(ids["course"])),
+                "experiment": bool(await exp_repo.get(ids["experiment"])),
+                "submission": bool(await sub_repo.get(ids["submission"])),
+                "pdf": bool(await pdf_repo.get(ids["pdf"])),
+                "resource": bool(await resource_repo.get(ids["resource"])),
+                "attachment": bool(await attachment_repo.get(ids["attachment"])),
+                "kv": bool(await kv_repo.get(ids["kv"])),
+                "log": bool(await log_repo.get(ids["log"])),
+            }
+            print(json.dumps({"self_check": "ok", "checks": checks}, ensure_ascii=False))
+            if not all(checks.values()):
+                return 1
+            return 0
+        finally:
+            try:
+                pdf = await pdf_repo.get(ids["pdf"])
+                if pdf:
+                    await pdf_repo.delete(ids["pdf"])
+                submission = await sub_repo.get(ids["submission"])
+                if submission:
+                    await sub_repo.delete(ids["submission"])
+                attachment = await attachment_repo.get(ids["attachment"])
+                if attachment:
+                    await attachment_repo.delete(ids["attachment"])
+                resource = await resource_repo.get(ids["resource"])
+                if resource:
+                    await resource_repo.delete(ids["resource"])
+                experiment = await exp_repo.get(ids["experiment"])
+                if experiment:
+                    await exp_repo.delete(ids["experiment"])
+                course = await course_repo.get(ids["course"])
+                if course:
+                    await course_repo.delete(ids["course"])
+                row = await kv_repo.get(ids["kv"])
+                if row:
+                    await db.delete(row)
+                log = await log_repo.get(ids["log"])
+                if log:
+                    await db.delete(log)
+                student = await user_repo.get_by_username(ids["student"])
+                if student:
+                    await user_repo.delete(student.id)
+                teacher = await user_repo.get_by_username(ids["teacher"])
+                if teacher:
+                    await user_repo.delete(teacher.id)
+                await auth_repo.delete_by_username(ids["student"])
+                await auth_repo.delete_by_username(ids["teacher"])
+                classes = await user_repo.list_classes()
+                for item in classes:
+                    if item.id == ids["class"]:
+                        await db.delete(item)
+                await db.commit()
+            except Exception:
+                await db.rollback()
+        break
+    return 2
+
+
+def main() -> int:
+    try:
+        return asyncio.run(_run())
+    finally:
+        try:
+            asyncio.run(close_db_engine())
+        except RuntimeError:
+            pass
+
+
+if __name__ == "__main__":
+    raise SystemExit(main())
+
diff --git a/backend/app/services/admin_service.py b/backend/app/services/admin_service.py
new file mode 100644
index 0000000..5ca4deb
--- /dev/null
+++ b/backend/app/services/admin_service.py
@@ -0,0 +1,1237 @@
+?from __future__ import annotations
+
+import mimetypes
+import os
+import shutil
+import uuid
+from copy import deepcopy
+from datetime import datetime
+from typing import Optional
+import io
+
+from fastapi import File, HTTPException, UploadFile
+from fastapi.responses import FileResponse, StreamingResponse
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from ..config import (
+    ALLOWED_RESOURCE_EXTENSIONS,
+    DEFAULT_ADMISSION_YEAR_OPTIONS,
+    DEFAULT_PASSWORD,
+    DEFAULT_RESOURCE_ROLE_LIMITS,
+    UPLOAD_DIR,
+)
+from ..repositories import (
+    AuthUserRepository,
+    OperationLogRepository,
+    PasswordHashRepository,
+    ResourceRepository,
+    SecurityQuestionRepository,
+    StudentExperimentRepository,
+    SubmissionPdfRepository,
+    UserRepository,
+)
+from .identity_service import ensure_admin, ensure_teacher_or_admin, normalize_text, resolve_user_role
+from .kv_policy_service import (
+    default_resource_policy_payload,
+    get_kv_json,
+    normalize_resource_budget,
+    normalize_resource_quota,
+    size_to_bytes,
+    upsert_kv_json,
+)
+from .operation_log_service import append_operation_log
+
+
+class AdminService:
+    def __init__(self, main_module, db: AsyncSession):
+        self.main = main_module
+        self.db = db
+
+    async def _commit(self):
+        try:
+            await self.db.commit()
+        except Exception as exc:
+            await self.db.rollback()
+            raise HTTPException(status_code=500, detail="管理员操作写入失败") from exc
+
+    async def _ensure_admin(self, username: str) -> str:
+        return await ensure_admin(self.db, username)
+
+    async def _ensure_teacher(self, username: str) -> tuple[str, str]:
+        return await ensure_teacher_or_admin(self.db, username)
+
+    @staticmethod
+    def _admission_year(value) -> str:
+        raw = normalize_text(value)
+        if not raw:
+            return ""
+        digits = "".join(ch for ch in raw if ch.isdigit())
+        if len(digits) == 4 and digits.startswith("20"):
+            return digits
+        if len(digits) == 2:
+            return f"20{digits}"
+        return ""
+
+    @staticmethod
+    def _infer_admission_year(student_id: str) -> str:
+        normalized = normalize_text(student_id)
+        if len(normalized) >= 2 and normalized[:2].isdigit():
+            return f"20{normalized[:2]}"
+        return ""
+
+    @staticmethod
+    def _build_class_name(admission_year: str, major_name: str, class_name: str) -> str:
+        year = AdminService._admission_year(admission_year)
+        major = normalize_text(major_name)
+        name = normalize_text(class_name)
+        if not (year and major and name):
+            return ""
+        return f"{year}级{major}{name}"
+
+    @staticmethod
+    def _format_admission_year_label(admission_year: str) -> str:
+        normalized = AdminService._admission_year(admission_year)
+        return f"{normalized}级" if normalized else ""
+
+    @staticmethod
+    def _resource_preview_mode(file_type: str) -> str:
+        normalized = normalize_text(file_type).lower().lstrip(".")
+        if normalized == "pdf":
+            return "pdf"
+        if normalized in {"xls", "xlsx"}:
+            return "sheet"
+        if normalized in {"md", "markdown"}:
+            return "markdown"
+        if normalized in {"txt", "csv", "json", "py", "log"}:
+            return "text"
+        if normalized == "docx":
+            return "docx"
+        return "unsupported"
+
+    def _resource_payload(self, row, route_prefix: str = "/api/admin/resources") -> dict:
+        normalized_prefix = route_prefix.rstrip("/")
+        preview_mode = self._resource_preview_mode(row.file_type)
+        return {
+            "id": row.id,
+            "filename": row.filename,
+            "file_type": row.file_type,
+            "content_type": row.content_type,
+            "size": row.size,
+            "created_at": row.created_at,
+            "created_by": row.created_by,
+            "preview_mode": preview_mode,
+            "previewable": preview_mode != "unsupported",
+            "preview_url": f"{normalized_prefix}/{row.id}/preview",
+            "download_url": f"{normalized_prefix}/{row.id}/download",
+        }
+
+    @staticmethod
+    def _operation_log_to_dict(record) -> dict:
+        return {
+            "id": record.id,
+            "operator": record.operator,
+            "action": record.action,
+            "target": record.target,
+            "detail": record.detail,
+            "success": bool(record.success),
+            "created_at": record.created_at.isoformat() if record.created_at else "",
+        }
+
+    async def _list_classes(self):
+        return await UserRepository(self.db).list_classes()
+
+    async def _accessible_classes(self, teacher_username: str, role: str):
+        rows = await self._list_classes()
+        if role == "admin":
+            return list(rows)
+        return [item for item in rows if normalize_text(item.created_by) == teacher_username]
+
+    async def _student_rows(self):
+        return await UserRepository(self.db).list_by_role("student")
+
+    async def _class_owner_map(self) -> dict[str, str]:
+        rows = await self._list_classes()
+        mapping: dict[str, str] = {}
+        for row in rows:
+            if normalize_text(row.name):
+                mapping[row.name] = normalize_text(row.created_by)
+        return mapping
+
+    @staticmethod
+    def _student_owner_username(student_row, class_owner_map: dict[str, str]) -> str:
+        owner = normalize_text(student_row.created_by)
+        if owner:
+            return owner
+        return normalize_text(class_owner_map.get(student_row.class_name, ""))
+
+    @classmethod
+    def _student_visible_to_teacher(cls, student_row, teacher_username: str, role: str, class_owner_map: dict[str, str]) -> bool:
+        if role == "admin":
+            return True
+        return cls._student_owner_username(student_row, class_owner_map) == teacher_username
+
+    async def _load_resource_policy(self) -> dict:
+        payload = await get_kv_json(self.db, "resource_policy", default_resource_policy_payload())
+        defaults = {}
+        raw_defaults = payload.get("defaults", {}) if isinstance(payload, dict) else {}
+        for role in DEFAULT_RESOURCE_ROLE_LIMITS:
+            defaults[role] = normalize_resource_quota((raw_defaults or {}).get(role), role)
+        budget = normalize_resource_budget((payload or {}).get("budget", {}))
+        overrides = {}
+        raw_overrides = (payload or {}).get("overrides", {})
+        if isinstance(raw_overrides, dict):
+            for username, quota in raw_overrides.items():
+                normalized_username = normalize_text(username)
+                if not normalized_username:
+                    continue
+                role_name = await resolve_user_role(self.db, normalized_username) or "student"
+                normalized_quota = normalize_resource_quota(quota, role_name)
+                normalized_quota["updated_by"] = normalize_text((quota or {}).get("updated_by")) or "system"
+                normalized_quota["updated_at"] = normalize_text((quota or {}).get("updated_at")) or datetime.now().isoformat()
+                normalized_quota["note"] = normalize_text((quota or {}).get("note"))[:200]
+                overrides[normalized_username] = normalized_quota
+        return {"defaults": defaults, "budget": budget, "overrides": overrides}
+
+    async def _save_resource_policy(self, payload: dict) -> None:
+        await upsert_kv_json(self.db, "resource_policy", payload)
+
+    async def _managed_users(self) -> list[dict]:
+        auth_repo = AuthUserRepository(self.db)
+        user_repo = UserRepository(self.db)
+
+        users: list[dict] = []
+        seen: set[str] = set()
+
+        for row in await auth_repo.list_all():
+            username = normalize_text(row.username or row.email)
+            role = normalize_text(getattr(row.role, "value", row.role)).lower() or "student"
+            if not username or username in seen:
+                continue
+            seen.add(username)
+            users.append(
+                {
+                    "username": username,
+                    "role": role,
+                    "real_name": username,
+                    "student_id": "",
+                    "class_name": "",
+                    "organization": "",
+                }
+            )
+
+        for row in await user_repo.list_by_role("teacher"):
+            username = normalize_text(row.username)
+            if not username or username in seen:
+                continue
+            seen.add(username)
+            users.append(
+                {
+                    "username": username,
+                    "role": "teacher",
+                    "real_name": normalize_text(row.real_name) or username,
+                    "student_id": "",
+                    "class_name": "",
+                    "organization": "",
+                }
+            )
+
+        for row in await user_repo.list_by_role("student"):
+            username = normalize_text(row.username or row.student_id)
+            if not username or username in seen:
+                continue
+            seen.add(username)
+            users.append(
+                {
+                    "username": username,
+                    "role": "student",
+                    "real_name": normalize_text(row.real_name) or username,
+                    "student_id": normalize_text(row.student_id),
+                    "class_name": normalize_text(row.class_name),
+                    "organization": normalize_text(row.organization),
+                }
+            )
+
+        role_order = {"admin": 0, "teacher": 1, "student": 2}
+        users.sort(key=lambda item: (role_order.get(item["role"], 9), item["username"]))
+        return users
+
+    @staticmethod
+    def _quota_from_policy(username: str, role: str, policy: dict) -> tuple[dict, str, dict]:
+        defaults = policy.get("defaults", {})
+        role_key = role if role in DEFAULT_RESOURCE_ROLE_LIMITS else "student"
+        base = normalize_resource_quota(defaults.get(role_key), role_key)
+        overrides = policy.get("overrides", {})
+        custom = overrides.get(username) if isinstance(overrides, dict) else None
+        if isinstance(custom, dict):
+            quota = normalize_resource_quota(custom, role_key)
+            return quota, "custom", {
+                "updated_by": normalize_text(custom.get("updated_by")) or "unknown",
+                "updated_at": normalize_text(custom.get("updated_at")),
+                "note": normalize_text(custom.get("note")),
+            }
+        return base, "default", {"updated_by": "system", "updated_at": "", "note": ""}
+
+    def _resource_assignment_summary(self, rows: list[dict], budget: dict) -> dict:
+        assigned_cpu = 0.0
+        assigned_memory = 0
+        assigned_storage = 0
+        active_cpu = 0.0
+        active_memory = 0
+        active_storage = 0
+        running_servers = 0
+
+        for item in rows:
+            quota = item.get("quota", {})
+            cpu = float(quota.get("cpu_limit", 0.0) or 0.0)
+            memory = size_to_bytes(str(quota.get("memory_limit", "0B")))
+            storage = size_to_bytes(str(quota.get("storage_limit", "0B")))
+            assigned_cpu += cpu
+            assigned_memory += memory
+            assigned_storage += storage
+            if item.get("server_running"):
+                running_servers += 1
+                active_cpu += cpu
+                active_memory += memory
+                active_storage += storage
+
+        budget_cpu = float(budget.get("max_total_cpu", 0.0) or 0.0)
+        budget_memory = size_to_bytes(str(budget.get("max_total_memory", "0B")))
+        budget_storage = size_to_bytes(str(budget.get("max_total_storage", "0B")))
+        return {
+            "total_users": len(rows),
+            "teachers": len([item for item in rows if item["role"] == "teacher"]),
+            "students": len([item for item in rows if item["role"] == "student"]),
+            "admins": len([item for item in rows if item["role"] == "admin"]),
+            "running_servers": running_servers,
+            "assigned_cpu": round(assigned_cpu, 3),
+            "assigned_memory_bytes": assigned_memory,
+            "assigned_storage_bytes": assigned_storage,
+            "active_cpu": round(active_cpu, 3),
+            "active_memory_bytes": active_memory,
+            "active_storage_bytes": active_storage,
+            "budget_cpu": budget_cpu,
+            "budget_memory_bytes": budget_memory,
+            "budget_storage_bytes": budget_storage,
+            "assigned_cpu_ratio": round((assigned_cpu / budget_cpu) if budget_cpu > 0 else 0.0, 4),
+            "assigned_memory_ratio": round((assigned_memory / budget_memory) if budget_memory > 0 else 0.0, 4),
+            "assigned_storage_ratio": round((assigned_storage / budget_storage) if budget_storage > 0 else 0.0, 4),
+        }
+
+    @staticmethod
+    def _validate_budget(summary: dict, budget: dict):
+        if not budget.get("enforce_budget"):
+            return
+        if summary["assigned_cpu"] > summary["budget_cpu"] + 1e-9:
+            raise HTTPException(status_code=409, detail="分配失败：CPU总配额超出服务器预算")
+        if summary["assigned_memory_bytes"] > summary["budget_memory_bytes"]:
+            raise HTTPException(status_code=409, detail="分配失败：内存总配额超出服务器预算")
+        if summary["assigned_storage_bytes"] > summary["budget_storage_bytes"]:
+            raise HTTPException(status_code=409, detail="分配失败：存储总配额超出服务器预算")
+
+    async def _collect_resource_control_users(self, policy: dict) -> list[dict]:
+        users = await self._managed_users()
+        hub_map = self.main._hub_user_state_map()
+        rows = []
+        for item in users:
+            username = item["username"]
+            role = item["role"]
+            quota, source, meta = self._quota_from_policy(username, role, policy)
+            hub_state = self.main._extract_server_state(hub_map.get(username))
+            rows.append(
+                {
+                    **item,
+                    "quota": quota,
+                    "quota_source": source,
+                    "quota_updated_by": meta.get("updated_by", ""),
+                    "quota_updated_at": meta.get("updated_at", ""),
+                    "quota_note": meta.get("note", ""),
+                    **hub_state,
+                }
+            )
+        return rows
+    async def list_admin_teachers(self, admin_username: str):
+        await self._ensure_admin(admin_username)
+        user_rows = await UserRepository(self.db).list_by_role("teacher")
+        auth_rows = await AuthUserRepository(self.db).list_by_role("teacher")
+        auth_usernames = {normalize_text(item.username or item.email) for item in auth_rows if normalize_text(item.username or item.email)}
+
+        teachers = {}
+        for row in user_rows:
+            username = normalize_text(row.username)
+            if not username:
+                continue
+            teachers[username] = {
+                "username": username,
+                "real_name": normalize_text(row.real_name) or username,
+                "source": "registry",
+                "created_by": normalize_text(row.created_by) or "system",
+                "created_at": row.created_at,
+            }
+        for username in sorted(auth_usernames):
+            teachers.setdefault(
+                username,
+                {
+                    "username": username,
+                    "real_name": username,
+                    "source": "registry",
+                    "created_by": "system",
+                    "created_at": None,
+                },
+            )
+        return sorted(teachers.values(), key=lambda item: item["username"])
+
+    async def create_admin_teacher(self, payload):
+        admin_username = await self._ensure_admin(payload.admin_username)
+        teacher_username = normalize_text(payload.username)
+        real_name = normalize_text(payload.real_name) or teacher_username
+        if not teacher_username:
+            raise HTTPException(status_code=400, detail="教师账号不能为空")
+
+        if await resolve_user_role(self.db, teacher_username) == "admin":
+            raise HTTPException(status_code=409, detail="账号与管理员冲突")
+
+        user_repo = UserRepository(self.db)
+        if await user_repo.get_student_by_student_id(teacher_username):
+            raise HTTPException(status_code=409, detail="账号与学生学号冲突")
+        existing_teacher = await user_repo.get_by_username(teacher_username)
+        if existing_teacher and normalize_text(existing_teacher.role).lower() == "teacher":
+            raise HTTPException(status_code=409, detail="教师账号已存在")
+
+        now = datetime.now()
+        teacher_row = await user_repo.upsert(
+            {
+                "id": existing_teacher.id if existing_teacher else str(uuid.uuid4()),
+                "username": teacher_username,
+                "role": "teacher",
+                "real_name": real_name,
+                "student_id": None,
+                "class_name": "",
+                "admission_year": "",
+                "organization": "",
+                "phone": "",
+                "password_hash": "",
+                "security_question": "",
+                "security_answer_hash": "",
+                "created_by": admin_username,
+                "is_active": True,
+                "created_at": existing_teacher.created_at if existing_teacher else now,
+                "updated_at": now,
+                "extra": {},
+            }
+        )
+
+        default_hash = self.main._hash_password(DEFAULT_PASSWORD)
+        auth_repo = AuthUserRepository(self.db)
+        await auth_repo.upsert_by_email(
+            {
+                "id": str(uuid.uuid4()),
+                "email": teacher_username,
+                "username": teacher_username,
+                "role": "teacher",
+                "password_hash": default_hash,
+                "is_active": True,
+                "created_at": now,
+                "updated_at": now,
+            }
+        )
+
+        await append_operation_log(
+            self.db,
+            operator=admin_username,
+            action="teachers.create",
+            target=teacher_username,
+            detail=f"real_name={real_name}",
+        )
+        await self._commit()
+        return {
+            "message": "教师账号已创建",
+            "teacher": {
+                "username": teacher_username,
+                "real_name": real_name,
+                "source": "registry",
+                "created_by": admin_username,
+                "created_at": teacher_row.created_at,
+            },
+        }
+
+    async def delete_admin_teacher(self, teacher_username: str, admin_username: str):
+        normalized_admin = await self._ensure_admin(admin_username)
+        normalized_teacher = normalize_text(teacher_username)
+        if not normalized_teacher:
+            raise HTTPException(status_code=400, detail="教师账号不能为空")
+
+        user_repo = UserRepository(self.db)
+        teacher_row = await user_repo.get_by_username(normalized_teacher)
+        if teacher_row is None or normalize_text(teacher_row.role).lower() != "teacher":
+            raise HTTPException(status_code=404, detail="教师账号不存在")
+
+        await user_repo.delete(teacher_row.id)
+        await AuthUserRepository(self.db).delete_by_username(normalized_teacher)
+        await PasswordHashRepository(self.db).delete_by_username(normalized_teacher)
+        sec_repo = SecurityQuestionRepository(self.db)
+        sec_row = await sec_repo.get_by_username(normalized_teacher)
+        if sec_row is not None:
+            await self.db.delete(sec_row)
+
+        policy = await self._load_resource_policy()
+        overrides = policy.get("overrides", {})
+        if isinstance(overrides, dict) and normalized_teacher in overrides:
+            overrides.pop(normalized_teacher, None)
+            policy["overrides"] = overrides
+            await self._save_resource_policy(policy)
+
+        await append_operation_log(
+            self.db,
+            operator=normalized_admin,
+            action="teachers.delete",
+            target=normalized_teacher,
+        )
+        await self._commit()
+        return {"message": "教师账号已删除", "username": normalized_teacher}
+
+    async def list_admin_classes(self, teacher_username: str):
+        normalized_teacher, role = await self._ensure_teacher(teacher_username)
+        rows = await self._accessible_classes(normalized_teacher, role)
+        payload = [
+            self.main.ClassRecord(id=row.id, name=row.name, created_by=row.created_by, created_at=row.created_at)
+            for row in rows
+        ]
+        payload.sort(key=lambda item: item.name)
+        return payload
+
+    async def download_class_template(self, teacher_username: str, format: str = "xlsx"):
+        await self._ensure_teacher(teacher_username)
+        template_format = format.lower()
+        if template_format == "csv":
+            payload = self.main._build_class_csv_template()
+            return StreamingResponse(
+                io.BytesIO(payload),
+                media_type="text/csv; charset=utf-8",
+                headers={"Content-Disposition": "attachment; filename=class_import_template.csv"},
+            )
+        if template_format == "xlsx":
+            payload = self.main._build_class_xlsx_template()
+            return StreamingResponse(
+                io.BytesIO(payload),
+                media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
+                headers={"Content-Disposition": "attachment; filename=class_import_template.xlsx"},
+            )
+        raise HTTPException(status_code=400, detail="format 必须是 xlsx 或 csv")
+
+    async def import_admin_classes(self, teacher_username: str, file: UploadFile = File(...)):
+        normalized_teacher, role = await self._ensure_teacher(teacher_username)
+        if not file.filename:
+            raise HTTPException(status_code=400, detail="文件名不能为空")
+
+        file_content = await file.read()
+        parsed_rows = self.main._parse_class_import_rows(file.filename, file_content)
+        now = datetime.now()
+
+        existing_rows = await self._accessible_classes(normalized_teacher, role)
+        existing_class_names = {item.name for item in existing_rows}
+        file_class_names = set()
+        success_classes = []
+        errors = []
+        skipped_count = 0
+
+        for row_number, row in parsed_rows:
+            admission_year_raw, major_name, class_name = row
+            normalized_year = self._admission_year(admission_year_raw)
+            normalized_major = normalize_text(major_name)
+            normalized_class = normalize_text(class_name)
+
+            if not all([normalized_year, normalized_major, normalized_class]):
+                errors.append({"row": row_number, "reason": "required fields cannot be empty"})
+                continue
+
+            merged_class_name = self._build_class_name(normalized_year, normalized_major, normalized_class)
+            if not merged_class_name:
+                errors.append({"row": row_number, "reason": "班级名称格式无效"})
+                continue
+
+            if merged_class_name in existing_class_names:
+                skipped_count += 1
+                errors.append({"row": row_number, "reason": f"班级重复（系统中已存在）: {merged_class_name}"})
+                continue
+            if merged_class_name in file_class_names:
+                skipped_count += 1
+                errors.append({"row": row_number, "reason": f"班级重复（文件内）: {merged_class_name}"})
+                continue
+
+            file_class_names.add(merged_class_name)
+            success_classes.append(
+                {
+                    "id": str(uuid.uuid4()),
+                    "name": merged_class_name,
+                    "created_by": normalized_teacher,
+                    "created_at": now,
+                }
+            )
+
+        user_repo = UserRepository(self.db)
+        for payload in success_classes:
+            await user_repo.upsert_class(payload)
+
+        await append_operation_log(
+            self.db,
+            operator=normalized_teacher,
+            action="classes.import",
+            target="classes",
+            detail=f"success={len(success_classes)}, skipped={skipped_count}, failed={len(errors) - skipped_count}",
+        )
+        await self._commit()
+        failed_count = len(errors) - skipped_count
+        return {
+            "total_rows": len(parsed_rows),
+            "success_count": len(success_classes),
+            "skipped_count": skipped_count,
+            "failed_count": failed_count,
+            "errors": errors,
+        }
+
+    async def create_admin_class(self, payload):
+        normalized_teacher, role = await self._ensure_teacher(payload.teacher_username)
+        class_name = normalize_text(payload.name)
+        if not class_name:
+            raise HTTPException(status_code=400, detail="班级名称不能为空")
+
+        existing_rows = await self._accessible_classes(normalized_teacher, role)
+        if any(item.name == class_name for item in existing_rows):
+            raise HTTPException(status_code=400, detail="班级已存在")
+
+        record = {
+            "id": str(uuid.uuid4()),
+            "name": class_name,
+            "created_by": normalized_teacher,
+            "created_at": datetime.now(),
+        }
+        await UserRepository(self.db).upsert_class(record)
+        await append_operation_log(
+            self.db,
+            operator=normalized_teacher,
+            action="classes.create",
+            target=class_name,
+            detail=f"class_id={record['id']}",
+        )
+        await self._commit()
+        return self.main.ClassRecord(**record)
+
+    async def delete_admin_class(self, class_id: str, teacher_username: str):
+        normalized_teacher, role = await self._ensure_teacher(teacher_username)
+        class_rows = await self._list_classes()
+        class_record = next((item for item in class_rows if item.id == class_id), None)
+        if class_record is None:
+            raise HTTPException(status_code=404, detail="班级不存在")
+
+        class_owner = normalize_text(class_record.created_by)
+        if role != "admin" and class_owner != normalized_teacher:
+            raise HTTPException(status_code=403, detail="不能删除其他教师创建的班级")
+
+        class_owner_map = await self._class_owner_map()
+        student_rows = await self._student_rows()
+        for item in student_rows:
+            owner = self._student_owner_username(item, class_owner_map)
+            if item.class_name == class_record.name and owner == class_owner:
+                raise HTTPException(status_code=409, detail="班级已被学生使用，无法删除")
+
+        await self.db.delete(class_record)
+        await append_operation_log(
+            self.db,
+            operator=normalized_teacher,
+            action="classes.delete",
+            target=class_record.name,
+            detail=f"class_id={class_id}",
+        )
+        await self._commit()
+        return {"message": "班级已删除"}
+
+    async def download_student_template(self, teacher_username: str, format: str = "xlsx"):
+        await self._ensure_teacher(teacher_username)
+        template_format = format.lower()
+        if template_format == "csv":
+            payload = self.main._build_csv_template()
+            return StreamingResponse(
+                io.BytesIO(payload),
+                media_type="text/csv; charset=utf-8",
+                headers={"Content-Disposition": "attachment; filename=student_import_template.csv"},
+            )
+        if template_format == "xlsx":
+            payload = self.main._build_xlsx_template()
+            return StreamingResponse(
+                io.BytesIO(payload),
+                media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
+                headers={"Content-Disposition": "attachment; filename=student_import_template.xlsx"},
+            )
+        raise HTTPException(status_code=400, detail="format 必须是 xlsx 或 csv")
+
+    async def import_students(self, teacher_username: str, file: UploadFile = File(...)):
+        normalized_teacher, role = await self._ensure_teacher(teacher_username)
+        if not file.filename:
+            raise HTTPException(status_code=400, detail="文件名不能为空")
+
+        file_content = await file.read()
+        parsed_rows = self.main._parse_student_import_rows(file.filename, file_content)
+
+        class_names = {item.name for item in await self._accessible_classes(normalized_teacher, role)}
+        user_repo = UserRepository(self.db)
+        existing_student_ids = {normalize_text(item.student_id or item.username) for item in await user_repo.list_by_role("student")}
+        file_student_ids = set()
+        now = datetime.now()
+
+        success_students = []
+        errors = []
+        skipped_count = 0
+
+        for row_number, row in parsed_rows:
+            student_id, real_name, class_name, organization, phone, admission_year_raw = row
+            admission_year = self._admission_year(admission_year_raw) or self._infer_admission_year(student_id)
+            if not all([student_id, real_name, class_name, organization, phone]):
+                errors.append({"row": row_number, "student_id": student_id, "reason": "字段不能为空"})
+                continue
+            if not admission_year:
+                errors.append({"row": row_number, "student_id": student_id, "reason": "入学年级无效"})
+                continue
+            if class_name not in class_names:
+                errors.append({"row": row_number, "student_id": student_id, "reason": "class does not exist"})
+                continue
+
+            role_value = await resolve_user_role(self.db, student_id)
+            if role_value in {"teacher", "admin"}:
+                errors.append({"row": row_number, "student_id": student_id, "reason": "student id conflicts with teacher account"})
+                continue
+
+            if student_id in existing_student_ids:
+                skipped_count += 1
+                errors.append({"row": row_number, "student_id": student_id, "reason": "学号重复（系统中已存在）"})
+                continue
+            if student_id in file_student_ids:
+                skipped_count += 1
+                errors.append({"row": row_number, "student_id": student_id, "reason": "duplicate student id in system"})
+                continue
+
+            file_student_ids.add(student_id)
+            success_students.append(
+                {
+                    "id": str(uuid.uuid4()),
+                    "username": student_id,
+                    "role": "student",
+                    "real_name": real_name,
+                    "student_id": student_id,
+                    "class_name": class_name,
+                    "admission_year": admission_year,
+                    "organization": organization,
+                    "phone": phone,
+                    "password_hash": self.main._hash_password(DEFAULT_PASSWORD),
+                    "security_question": "",
+                    "security_answer_hash": "",
+                    "created_by": normalized_teacher,
+                    "is_active": True,
+                    "created_at": now,
+                    "updated_at": now,
+                    "extra": {},
+                }
+            )
+
+        auth_repo = AuthUserRepository(self.db)
+        default_hash = self.main._hash_password(DEFAULT_PASSWORD)
+        for payload in success_students:
+            await user_repo.upsert(payload)
+            await auth_repo.upsert_by_email(
+                {
+                    "id": str(uuid.uuid4()),
+                    "email": payload["username"],
+                    "username": payload["username"],
+                    "role": "student",
+                    "password_hash": default_hash,
+                    "is_active": True,
+                    "created_at": now,
+                    "updated_at": now,
+                }
+            )
+
+        await append_operation_log(
+            self.db,
+            operator=normalized_teacher,
+            action="students.import",
+            target="students",
+            detail=f"success={len(success_students)}, skipped={skipped_count}, failed={len(errors) - skipped_count}",
+        )
+        await self._commit()
+        failed_count = len(errors) - skipped_count
+        return {
+            "total_rows": len(parsed_rows),
+            "success_count": len(success_students),
+            "skipped_count": skipped_count,
+            "failed_count": failed_count,
+            "errors": errors,
+        }
+
+    async def list_admin_students(
+        self,
+        teacher_username: str,
+        keyword: str = "",
+        class_name: str = "",
+        admission_year: str = "",
+        page: int = 1,
+        page_size: int = 20,
+    ):
+        normalized_teacher, role = await self._ensure_teacher(teacher_username)
+        page = max(page, 1)
+        page_size = max(1, min(page_size, 100))
+
+        normalized_keyword = normalize_text(keyword).lower()
+        normalized_class_name = normalize_text(class_name)
+        normalized_admission_year = self._admission_year(admission_year)
+        class_owner_map = await self._class_owner_map()
+        students = [
+            item
+            for item in await self._student_rows()
+            if self._student_visible_to_teacher(item, normalized_teacher, role, class_owner_map)
+        ]
+
+        if normalized_keyword:
+            students = [
+                item
+                for item in students
+                if normalized_keyword in normalize_text(item.student_id).lower()
+                or normalized_keyword in normalize_text(item.real_name).lower()
+            ]
+
+        if normalized_class_name:
+            students = [item for item in students if item.class_name == normalized_class_name]
+        if normalized_admission_year:
+            students = [
+                item for item in students if self._admission_year(item.admission_year) == normalized_admission_year
+            ]
+
+        students.sort(key=lambda item: item.created_at or datetime.min, reverse=True)
+        total = len(students)
+        start = (page - 1) * page_size
+        end = start + page_size
+        paged_students = students[start:end]
+        return {
+            "total": total,
+            "page": page,
+            "page_size": page_size,
+            "items": [
+                {
+                    "student_id": item.student_id,
+                    "username": item.username,
+                    "real_name": item.real_name,
+                    "class_name": item.class_name,
+                    "admission_year": self._admission_year(item.admission_year),
+                    "admission_year_label": self._format_admission_year_label(item.admission_year),
+                    "organization": item.organization,
+                    "phone": item.phone,
+                    "role": item.role,
+                    "created_at": item.created_at,
+                    "updated_at": item.updated_at,
+                }
+                for item in paged_students
+            ],
+        }
+
+    async def list_admission_year_options(self, teacher_username: str):
+        normalized_teacher, role = await self._ensure_teacher(teacher_username)
+        class_owner_map = await self._class_owner_map()
+        year_set = {year for year in DEFAULT_ADMISSION_YEAR_OPTIONS}
+        for item in await self._student_rows():
+            if not self._student_visible_to_teacher(item, normalized_teacher, role, class_owner_map):
+                continue
+            normalized = self._admission_year(item.admission_year)
+            if normalized:
+                year_set.add(normalized)
+        years = sorted(year_set)
+        return [{"value": year, "label": f"{year}级"} for year in years]
+
+    async def _delete_student_related_rows(self, student_row):
+        pdf_repo = SubmissionPdfRepository(self.db)
+        for pdf in await pdf_repo.list_by_student(student_row.student_id or student_row.username):
+            if pdf.file_path and os.path.exists(pdf.file_path):
+                try:
+                    os.remove(pdf.file_path)
+                except OSError:
+                    pass
+            await pdf_repo.delete(pdf.id)
+        await StudentExperimentRepository(self.db).delete_by_student(student_row.student_id or student_row.username)
+
+    async def reset_student_password(self, student_id: str, teacher_username: str):
+        normalized_teacher, role = await self._ensure_teacher(teacher_username)
+        repo = UserRepository(self.db)
+        student = await repo.get_student_by_student_id(student_id)
+        if not student:
+            raise HTTPException(status_code=404, detail="学生不存在")
+
+        class_owner_map = await self._class_owner_map()
+        if not self._student_visible_to_teacher(student, normalized_teacher, role, class_owner_map):
+            raise HTTPException(status_code=403, detail="不能操作其他教师的学生")
+
+        new_hash = self.main._hash_password(DEFAULT_PASSWORD)
+        student.password_hash = new_hash
+        student.updated_at = datetime.now()
+
+        auth_repo = AuthUserRepository(self.db)
+        auth_user = await auth_repo.get_by_login_identifier(student.username or student.student_id)
+        if auth_user is not None:
+            auth_user.password_hash = new_hash
+            auth_user.updated_at = datetime.now()
+
+        await append_operation_log(
+            self.db,
+            operator=normalized_teacher,
+            action="students.reset_password",
+            target=student_id,
+            detail="密码重置为默认密码",
+        )
+        await self._commit()
+        return {"message": "密码已重置", "student_id": student_id}
+
+    async def delete_student(self, student_id: str, teacher_username: str):
+        normalized_teacher, role = await self._ensure_teacher(teacher_username)
+        repo = UserRepository(self.db)
+        student = await repo.get_student_by_student_id(student_id)
+        if not student:
+            raise HTTPException(status_code=404, detail="学生不存在")
+
+        class_owner_map = await self._class_owner_map()
+        if not self._student_visible_to_teacher(student, normalized_teacher, role, class_owner_map):
+            raise HTTPException(status_code=403, detail="不能删除其他教师的学生")
+
+        await self._delete_student_related_rows(student)
+        await repo.delete(student.id)
+        await AuthUserRepository(self.db).delete_by_username(student.username or student.student_id)
+
+        await append_operation_log(
+            self.db,
+            operator=normalized_teacher,
+            action="students.delete",
+            target=student_id,
+            detail="删除学生账号",
+        )
+        await self._commit()
+        return {"message": "学生已删除", "student_id": student_id}
+
+    async def batch_delete_students(self, teacher_username: str, class_name: str = ""):
+        normalized_teacher, role = await self._ensure_teacher(teacher_username)
+        normalized_class_name = normalize_text(class_name)
+        if not normalized_class_name:
+            raise HTTPException(status_code=400, detail="class_name不能为空")
+
+        class_owner_map = await self._class_owner_map()
+        target_records = [
+            item
+            for item in await self._student_rows()
+            if item.class_name == normalized_class_name
+            and self._student_visible_to_teacher(item, normalized_teacher, role, class_owner_map)
+        ]
+        target_ids = [item.student_id for item in target_records]
+
+        user_repo = UserRepository(self.db)
+        auth_repo = AuthUserRepository(self.db)
+        for student in target_records:
+            await self._delete_student_related_rows(student)
+            await user_repo.delete(student.id)
+            await auth_repo.delete_by_username(student.username or student.student_id)
+
+        await append_operation_log(
+            self.db,
+            operator=normalized_teacher,
+            action="students.batch_delete",
+            target=normalized_class_name,
+            detail=f"class_name={normalized_class_name}, deleted={len(target_ids)}",
+        )
+        await self._commit()
+        return {
+            "message": "批量删除完成",
+            "class_name": normalized_class_name,
+            "deleted_count": len(target_ids),
+            "deleted_student_ids": target_ids,
+        }
+    async def get_resource_control_overview(self, admin_username: str):
+        await self._ensure_admin(admin_username)
+        policy = await self._load_resource_policy()
+        budget = normalize_resource_budget(policy.get("budget", {}))
+        users = await self._collect_resource_control_users(policy)
+        summary = self._resource_assignment_summary(users, budget)
+        return {
+            "budget": budget,
+            "summary": summary,
+            "defaults": policy.get("defaults", deepcopy(DEFAULT_RESOURCE_ROLE_LIMITS)),
+            "users": users,
+        }
+
+    async def upsert_user_resource_quota(self, username: str, payload):
+        normalized_admin = await self._ensure_admin(payload.admin_username)
+        target_user = normalize_text(username)
+        if not target_user:
+            raise HTTPException(status_code=400, detail="username不能为空")
+
+        policy = await self._load_resource_policy()
+        user_map = {item["username"]: item for item in await self._managed_users()}
+        user_item = user_map.get(target_user)
+        if not user_item:
+            raise HTTPException(status_code=404, detail="用户不存在，无法设置资源配额")
+
+        role = user_item["role"]
+        quota = normalize_resource_quota(
+            {
+                "cpu_limit": payload.cpu_limit,
+                "memory_limit": payload.memory_limit,
+                "storage_limit": payload.storage_limit,
+            },
+            role,
+        )
+        now_iso = datetime.now().isoformat()
+        next_override = {
+            **quota,
+            "updated_by": normalized_admin,
+            "updated_at": now_iso,
+            "note": normalize_text(payload.note)[:200],
+        }
+
+        simulated = deepcopy(policy)
+        simulated_overrides = dict(simulated.get("overrides", {}))
+        simulated_overrides[target_user] = next_override
+        simulated["overrides"] = simulated_overrides
+        simulated["budget"] = normalize_resource_budget(simulated.get("budget", {}))
+
+        simulated_rows = await self._collect_resource_control_users(simulated)
+        simulated_summary = self._resource_assignment_summary(simulated_rows, simulated["budget"])
+        self._validate_budget(simulated_summary, simulated["budget"])
+
+        await self._save_resource_policy(simulated)
+        await append_operation_log(
+            self.db,
+            operator=normalized_admin,
+            action="resource_quota.update",
+            target=target_user,
+            detail=f"cpu={quota['cpu_limit']}, memory={quota['memory_limit']}, storage={quota['storage_limit']}",
+        )
+        await self._commit()
+        target_row = next((item for item in simulated_rows if item["username"] == target_user), None)
+        return {
+            "message": "资源配额已更新",
+            "item": target_row,
+            "summary": simulated_summary,
+        }
+
+    async def delete_user_resource_quota_override(self, username: str, admin_username: str):
+        normalized_admin = await self._ensure_admin(admin_username)
+        target_user = normalize_text(username)
+        if not target_user:
+            raise HTTPException(status_code=400, detail="username不能为空")
+
+        if target_user not in {item["username"] for item in await self._managed_users()}:
+            raise HTTPException(status_code=404, detail="用户不存在")
+
+        policy = await self._load_resource_policy()
+        simulated = deepcopy(policy)
+        simulated_overrides = dict(simulated.get("overrides", {}))
+        simulated_overrides.pop(target_user, None)
+        simulated["overrides"] = simulated_overrides
+        simulated["budget"] = normalize_resource_budget(simulated.get("budget", {}))
+
+        simulated_rows = await self._collect_resource_control_users(simulated)
+        simulated_summary = self._resource_assignment_summary(simulated_rows, simulated["budget"])
+        self._validate_budget(simulated_summary, simulated["budget"])
+
+        await self._save_resource_policy(simulated)
+        await append_operation_log(
+            self.db,
+            operator=normalized_admin,
+            action="resource_quota.reset",
+            target=target_user,
+            detail="恢复默认资源配额",
+        )
+        await self._commit()
+        return {
+            "message": "该用户已恢复默认资源配额",
+            "username": target_user,
+            "summary": simulated_summary,
+        }
+
+    async def update_resource_budget(self, payload):
+        normalized_admin = await self._ensure_admin(payload.admin_username)
+        policy = await self._load_resource_policy()
+        budget = normalize_resource_budget(
+            {
+                "max_total_cpu": payload.max_total_cpu,
+                "max_total_memory": payload.max_total_memory,
+                "max_total_storage": payload.max_total_storage,
+                "enforce_budget": payload.enforce_budget,
+                "updated_by": normalized_admin,
+                "updated_at": datetime.now().isoformat(),
+            }
+        )
+
+        rows = await self._collect_resource_control_users(policy)
+        summary = self._resource_assignment_summary(rows, budget)
+        self._validate_budget(summary, budget)
+        policy["budget"] = budget
+        await self._save_resource_policy(policy)
+
+        await append_operation_log(
+            self.db,
+            operator=normalized_admin,
+            action="resource_budget.update",
+            target="server-budget",
+            detail=(
+                f"cpu={budget['max_total_cpu']}, memory={budget['max_total_memory']}, "
+                f"storage={budget['max_total_storage']}, enforce={budget['enforce_budget']}"
+            ),
+        )
+        await self._commit()
+        return {"message": "服务器资源预算已更新", "budget": budget, "summary": summary}
+
+    async def list_admin_operation_logs(self, admin_username: str, limit: int = 200):
+        await self._ensure_admin(admin_username)
+        safe_limit = max(1, min(limit, 1000))
+        repo = OperationLogRepository(self.db)
+        items = await repo.list_recent(safe_limit)
+        total = await repo.count()
+        return {
+            "total": total,
+            "limit": safe_limit,
+            "items": [self._operation_log_to_dict(item) for item in items],
+        }
+
+    async def cleanup_admin_operation_logs(self, admin_username: str, keep_recent: int = 200):
+        normalized_admin = await self._ensure_admin(admin_username)
+        safe_keep = max(0, min(keep_recent, 1000))
+        repo = OperationLogRepository(self.db)
+        removed_count = await repo.delete_except_recent(safe_keep)
+        await append_operation_log(
+            self.db,
+            operator=normalized_admin,
+            action="operation_logs.cleanup",
+            target="operation-logs",
+            detail=f"removed={removed_count}, keep_recent={safe_keep}",
+        )
+        await self._commit()
+        remaining = await repo.count()
+        return {
+            "message": "操作日志清理完成",
+            "removed_count": removed_count,
+            "remaining": remaining,
+        }
+
+    async def upload_resource_file(self, teacher_username: str, file: UploadFile = File(...)):
+        normalized_teacher, _ = await self._ensure_teacher(teacher_username)
+        if not file.filename:
+            raise HTTPException(status_code=400, detail="文件名不能为空")
+
+        original_filename = os.path.basename(file.filename)
+        extension = os.path.splitext(original_filename)[1].lower()
+        if extension not in ALLOWED_RESOURCE_EXTENSIONS:
+            raise HTTPException(status_code=400, detail="暂不支持该文件类型")
+
+        safe_filename = original_filename.replace(" ", "_").replace("/", "_").replace("\\", "_")
+        resource_id = str(uuid.uuid4())
+        file_path = os.path.join(UPLOAD_DIR, f"resource_{resource_id}_{safe_filename}")
+        try:
+            with open(file_path, "wb") as buffer:
+                shutil.copyfileobj(file.file, buffer)
+        except Exception as exc:
+            raise HTTPException(status_code=500, detail=f"文件保存失败: {exc}") from exc
+
+        file_size = os.path.getsize(file_path)
+        if file_size <= 0:
+            if os.path.exists(file_path):
+                os.remove(file_path)
+            raise HTTPException(status_code=400, detail="上传文件为空")
+
+        inferred_content_type = file.content_type or mimetypes.guess_type(original_filename)[0] or "application/octet-stream"
+        row = await ResourceRepository(self.db).create(
+            {
+                "id": resource_id,
+                "filename": original_filename,
+                "file_path": file_path,
+                "file_type": extension.lstrip("."),
+                "content_type": inferred_content_type,
+                "size": file_size,
+                "created_at": datetime.now(),
+                "updated_at": datetime.now(),
+                "created_by": normalized_teacher,
+            }
+        )
+        await self._commit()
+        return self._resource_payload(row)
+
+    async def list_resource_files(self, teacher_username: str, name: Optional[str] = None, file_type: Optional[str] = None):
+        await self._ensure_teacher(teacher_username)
+        normalized_name = normalize_text(name).lower()
+        normalized_type = normalize_text(file_type).lower().lstrip(".")
+
+        items = []
+        for row in await ResourceRepository(self.db).list_all():
+            if normalized_name and normalized_name not in normalize_text(row.filename).lower():
+                continue
+            if normalized_type and normalize_text(row.file_type).lower().lstrip(".") != normalized_type:
+                continue
+            if not os.path.exists(row.file_path):
+                continue
+            items.append(row)
+        items.sort(key=lambda item: item.created_at or datetime.min, reverse=True)
+        payload_items = [self._resource_payload(item) for item in items]
+        return {"total": len(payload_items), "items": payload_items}
+
+    async def get_resource_file_detail(self, resource_id: str, teacher_username: str):
+        await self._ensure_teacher(teacher_username)
+        row = await ResourceRepository(self.db).get(resource_id)
+        if not row:
+            raise HTTPException(status_code=404, detail="资源文件不存在")
+        if not os.path.exists(row.file_path):
+            await ResourceRepository(self.db).delete(resource_id)
+            await self._commit()
+            raise HTTPException(status_code=404, detail="资源文件不存在")
+
+        payload = self._resource_payload(row)
+        preview_mode = payload["preview_mode"]
+        if preview_mode in {"markdown", "text"}:
+            payload["preview_text"] = self.main._read_text_preview(row.file_path)
+        elif preview_mode == "docx":
+            payload["preview_text"] = self.main._read_docx_preview(row.file_path)
+        else:
+            payload["preview_text"] = ""
+        return payload
+
+    async def delete_resource_file(self, resource_id: str, teacher_username: str):
+        await self._ensure_teacher(teacher_username)
+        row = await ResourceRepository(self.db).get(resource_id)
+        if not row:
+            raise HTTPException(status_code=404, detail="资源文件不存在")
+        if os.path.exists(row.file_path):
+            try:
+                os.remove(row.file_path)
+            except OSError as exc:
+                raise HTTPException(status_code=500, detail=f"删除文件失败: {exc}") from exc
+        await ResourceRepository(self.db).delete(resource_id)
+        await self._commit()
+        return {"message": "资源文件已删除", "id": resource_id}
+
+    async def preview_resource_file(self, resource_id: str, teacher_username: str):
+        await self._ensure_teacher(teacher_username)
+        row = await ResourceRepository(self.db).get(resource_id)
+        if not row or not os.path.exists(row.file_path):
+            raise HTTPException(status_code=404, detail="资源文件不存在")
+        if self._resource_preview_mode(row.file_type) != "pdf":
+            raise HTTPException(status_code=400, detail="该文件类型不支持二进制在线预览")
+        return FileResponse(
+            path=row.file_path,
+            filename="document.pdf",
+            media_type="application/pdf",
+            content_disposition_type="inline",
+        )
+
+    async def download_resource_file(self, resource_id: str, teacher_username: str):
+        await self._ensure_teacher(teacher_username)
+        row = await ResourceRepository(self.db).get(resource_id)
+        if not row or not os.path.exists(row.file_path):
+            raise HTTPException(status_code=404, detail="资源文件不存在")
+        media_type = row.content_type or mimetypes.guess_type(row.filename)[0] or "application/octet-stream"
+        return FileResponse(
+            path=row.file_path,
+            filename=row.filename,
+            media_type=media_type,
+            content_disposition_type="attachment",
+        )
diff --git a/backend/app/services/identity_service.py b/backend/app/services/identity_service.py
new file mode 100644
index 0000000..8a80890
--- /dev/null
+++ b/backend/app/services/identity_service.py
@@ -0,0 +1,75 @@
+from __future__ import annotations
+
+from typing import Any
+
+from fastapi import HTTPException
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from ..repositories import AuthUserRepository, UserRepository
+
+
+def normalize_text(value: Any) -> str:
+    if value is None:
+        return ""
+    return str(value).strip()
+
+
+def role_value(value: Any) -> str:
+    if hasattr(value, "value"):
+        return normalize_text(getattr(value, "value")).lower()
+    return normalize_text(value).lower()
+
+
+async def resolve_user_role(db: AsyncSession, username: str) -> str:
+    normalized = normalize_text(username)
+    if not normalized:
+        return ""
+
+    auth_row = await AuthUserRepository(db).get_by_login_identifier(normalized)
+    if auth_row is not None:
+        role = role_value(auth_row.role)
+        if role:
+            return role
+
+    user_repo = UserRepository(db)
+    user = await user_repo.get_by_username(normalized)
+    if user is None:
+        user = await user_repo.get_student_by_student_id(normalized)
+    if user is None:
+        return ""
+    return normalize_text(user.role).lower() or "student"
+
+
+async def ensure_admin(db: AsyncSession, username: str) -> str:
+    normalized = normalize_text(username)
+    if not normalized:
+        raise HTTPException(status_code=403, detail="权限不足，需要管理员账号")
+    role = await resolve_user_role(db, normalized)
+    if role != "admin":
+        raise HTTPException(status_code=403, detail="权限不足，需要管理员账号")
+    return normalized
+
+
+async def ensure_teacher_or_admin(db: AsyncSession, username: str) -> tuple[str, str]:
+    normalized = normalize_text(username)
+    if not normalized:
+        raise HTTPException(status_code=403, detail="权限不足")
+    role = await resolve_user_role(db, normalized)
+    if role not in {"teacher", "admin"}:
+        raise HTTPException(status_code=403, detail="权限不足")
+    return normalized, role
+
+
+async def ensure_student_user(db: AsyncSession, student_id_or_username: str):
+    normalized = normalize_text(student_id_or_username)
+    if not normalized:
+        raise HTTPException(status_code=404, detail="学生不存在")
+
+    repo = UserRepository(db)
+    row = await repo.get_student_by_student_id(normalized)
+    if row is None:
+        row = await repo.get_by_username(normalized)
+    if row is None or normalize_text(row.role).lower() != "student":
+        raise HTTPException(status_code=404, detail="学生不存在")
+    return row
+
diff --git a/backend/app/services/kv_policy_service.py b/backend/app/services/kv_policy_service.py
new file mode 100644
index 0000000..b2e122f
--- /dev/null
+++ b/backend/app/services/kv_policy_service.py
@@ -0,0 +1,171 @@
+from __future__ import annotations
+
+from copy import deepcopy
+from datetime import datetime
+from typing import Any
+
+from fastapi import HTTPException
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from ..config import DEFAULT_RESOURCE_ROLE_LIMITS, DEFAULT_SERVER_RESOURCE_BUDGET
+from ..repositories import KVStoreRepository
+from .identity_service import normalize_text
+
+_SIZE_FACTORS = {
+    "B": 1,
+    "K": 1024,
+    "M": 1024 ** 2,
+    "G": 1024 ** 3,
+    "T": 1024 ** 4,
+}
+
+
+def _size_unit(default_value: str) -> str:
+    raw = normalize_text(default_value).upper()
+    if raw.endswith("KB") or raw.endswith("K"):
+        return "K"
+    if raw.endswith("MB") or raw.endswith("M"):
+        return "M"
+    if raw.endswith("GB") or raw.endswith("G"):
+        return "G"
+    if raw.endswith("TB") or raw.endswith("T"):
+        return "T"
+    return "B"
+
+
+def normalize_size_limit(value: Any, default_value: str) -> str:
+    raw = normalize_text(value)
+    if not raw:
+        return default_value
+
+    text = raw.upper().replace(" ", "")
+    number = ""
+    unit = ""
+    for ch in text:
+        if ch.isdigit() or ch == ".":
+            number += ch
+        else:
+            unit += ch
+    if not number:
+        raise HTTPException(status_code=400, detail=f"资源大小格式无效: {raw}")
+    try:
+        size = float(number)
+    except ValueError as exc:
+        raise HTTPException(status_code=400, detail=f"资源大小格式无效: {raw}") from exc
+    if size <= 0:
+        raise HTTPException(status_code=400, detail=f"资源大小必须大于 0: {raw}")
+
+    if unit in {"", "B"}:
+        resolved_unit = _size_unit(default_value)
+    elif unit in {"K", "KB"}:
+        resolved_unit = "K"
+    elif unit in {"M", "MB"}:
+        resolved_unit = "M"
+    elif unit in {"G", "GB"}:
+        resolved_unit = "G"
+    elif unit in {"T", "TB"}:
+        resolved_unit = "T"
+    else:
+        raise HTTPException(status_code=400, detail=f"资源大小格式无效: {raw}")
+
+    if size.is_integer():
+        number_text = str(int(size))
+    else:
+        number_text = str(round(size, 3)).rstrip("0").rstrip(".")
+    return number_text if resolved_unit == "B" else f"{number_text}{resolved_unit}"
+
+
+def size_to_bytes(value: str) -> int:
+    raw = normalize_text(value).upper().replace(" ", "")
+    if not raw:
+        return 0
+    number = ""
+    unit = ""
+    for ch in raw:
+        if ch.isdigit() or ch == ".":
+            number += ch
+        else:
+            unit += ch
+    if not number:
+        return 0
+    try:
+        parsed = float(number)
+    except ValueError:
+        return 0
+    if unit in {"", "B"}:
+        factor = _SIZE_FACTORS["B"]
+    elif unit in {"K", "KB"}:
+        factor = _SIZE_FACTORS["K"]
+    elif unit in {"M", "MB"}:
+        factor = _SIZE_FACTORS["M"]
+    elif unit in {"G", "GB"}:
+        factor = _SIZE_FACTORS["G"]
+    elif unit in {"T", "TB"}:
+        factor = _SIZE_FACTORS["T"]
+    else:
+        factor = _SIZE_FACTORS["B"]
+    return int(parsed * factor)
+
+
+def default_resource_policy_payload() -> dict:
+    now_iso = datetime.now().isoformat()
+    return {
+        "defaults": deepcopy(DEFAULT_RESOURCE_ROLE_LIMITS),
+        "budget": {
+            **deepcopy(DEFAULT_SERVER_RESOURCE_BUDGET),
+            "updated_by": "system",
+            "updated_at": now_iso,
+        },
+        "overrides": {},
+    }
+
+
+def normalize_resource_quota(raw: dict | None, role: str) -> dict:
+    role_key = role if role in DEFAULT_RESOURCE_ROLE_LIMITS else "student"
+    base = DEFAULT_RESOURCE_ROLE_LIMITS[role_key]
+    source = raw or {}
+
+    try:
+        cpu_limit = float(source.get("cpu_limit", base["cpu_limit"]))
+    except (TypeError, ValueError):
+        cpu_limit = float(base["cpu_limit"])
+    cpu_limit = round(max(0.1, min(cpu_limit, 128.0)), 3)
+
+    memory_limit = normalize_size_limit(source.get("memory_limit", base["memory_limit"]), base["memory_limit"])
+    storage_limit = normalize_size_limit(source.get("storage_limit", base["storage_limit"]), base["storage_limit"])
+    return {
+        "cpu_limit": cpu_limit,
+        "memory_limit": memory_limit,
+        "storage_limit": storage_limit,
+    }
+
+
+def normalize_resource_budget(raw: dict | None) -> dict:
+    source = raw or {}
+    base = DEFAULT_SERVER_RESOURCE_BUDGET
+    try:
+        max_total_cpu = float(source.get("max_total_cpu", base["max_total_cpu"]))
+    except (TypeError, ValueError):
+        max_total_cpu = float(base["max_total_cpu"])
+    max_total_cpu = round(max(0.1, min(max_total_cpu, 1024.0)), 3)
+    return {
+        "max_total_cpu": max_total_cpu,
+        "max_total_memory": normalize_size_limit(source.get("max_total_memory", base["max_total_memory"]), base["max_total_memory"]),
+        "max_total_storage": normalize_size_limit(source.get("max_total_storage", base["max_total_storage"]), base["max_total_storage"]),
+        "enforce_budget": bool(source.get("enforce_budget", base["enforce_budget"])),
+        "updated_by": normalize_text(source.get("updated_by")) or "system",
+        "updated_at": normalize_text(source.get("updated_at")) or datetime.now().isoformat(),
+    }
+
+
+async def get_kv_json(db: AsyncSession, key: str, default: dict) -> dict:
+    repo = KVStoreRepository(db)
+    row = await repo.get(key)
+    payload = row.value_json if row is not None and isinstance(row.value_json, dict) else None
+    return deepcopy(payload) if payload is not None else deepcopy(default)
+
+
+async def upsert_kv_json(db: AsyncSession, key: str, payload: dict) -> None:
+    repo = KVStoreRepository(db)
+    await repo.upsert(key, deepcopy(payload))
+
diff --git a/backend/app/services/operation_log_service.py b/backend/app/services/operation_log_service.py
new file mode 100644
index 0000000..c2a352d
--- /dev/null
+++ b/backend/app/services/operation_log_service.py
@@ -0,0 +1,31 @@
+from __future__ import annotations
+
+import uuid
+from datetime import datetime
+
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from ..repositories import OperationLogRepository
+from .identity_service import normalize_text
+
+
+async def append_operation_log(
+    db: AsyncSession,
+    *,
+    operator: str,
+    action: str,
+    target: str,
+    detail: str = "",
+    success: bool = True,
+) -> None:
+    repo = OperationLogRepository(db)
+    await repo.append(
+        log_id=str(uuid.uuid4()),
+        operator=normalize_text(operator) or "unknown",
+        action=normalize_text(action) or "unknown",
+        target=normalize_text(target) or "-",
+        detail=normalize_text(detail)[:800],
+        success=bool(success),
+        created_at=datetime.now(),
+    )
+
